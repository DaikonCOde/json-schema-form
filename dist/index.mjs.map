{"version":3,"sources":["../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/types.js","../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/sets.js","../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/util.js","../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/positions.js","../node_modules/.pnpm/ret@0.2.2/node_modules/ret/lib/index.js","../node_modules/.pnpm/drange@1.1.1/node_modules/drange/lib/index.js","../node_modules/.pnpm/randexp@0.5.3/node_modules/randexp/lib/randexp.js","../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIntersection.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castArrayLikeObject.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/intersection.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignMergeValue.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isPlainObject.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_safeGet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toPlainObject.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMergeDeep.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMerge.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/merge.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mergeWith.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js","../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/set.js","../src/errors/messages.ts","../src/utils.ts","../src/validation/custom/date.ts","../src/field/schema.ts","../src/custom/order.ts","../src/validation/util.ts","../src/validation/array.ts","../src/validation/composition.ts","../src/validation/const.ts","../src/validation/enum.ts","../src/validation/file.ts","../src/validation/json-logic.ts","../src/validation/number.ts","../src/validation/object.ts","../node_modules/.pnpm/json-schema-typed@8.0.1/node_modules/json-schema-typed/draft-2020-12.ts","../src/validation/format.ts","../src/validation/string.ts","../src/validation/schema.ts","../src/validation/conditions.ts","../src/mutations.ts","../src/form.ts","../src/modify-schema.ts","../src/utils/layout.ts"],"sourcesContent":["module.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n","const types = require('./types');\n\nconst INTS = () => [{ type: types.RANGE , from: 48, to: 57 }];\n\nconst WORDS = () => {\n  return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nconst WHITESPACE = () => {\n  return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.RANGE, from: 8192, to: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nconst NOTANYCHAR = () => {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = () => ({ type: types.SET, set: WORDS(), not: false });\nexports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });\nexports.ints = () => ({ type: types.SET, set: INTS(), not: false });\nexports.notInts = () => ({ type: types.SET, set: INTS(), not: true });\nexports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });\nexports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });\nexports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });\n","const types = require('./types');\nconst sets  = require('./sets');\n\n\nconst CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nconst SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\\\\]^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 :\n      a16   ? parseInt(a16, 16) :\n      b16   ? parseInt(b16, 16) :\n      c8    ? parseInt(c8,   8) :\n      dctrl ? CTRL.indexOf(dctrl) :\n      SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[[\\]{}^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.<Array.<Object>, Number>}\n */\nexports.tokenizeClass = (str, regexpStr) => {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?([^])/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0),\n      });\n\n    } else if ((c = rs[12])) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = (regexp, msg) => {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};\n","const types = require('./types');\nexports.wordBoundary = () => ({ type: types.POSITION, value: 'b' });\nexports.nonWordBoundary = () => ({ type: types.POSITION, value: 'B' });\nexports.begin = () => ({ type: types.POSITION, value: '^' });\nexports.end = () => ({ type: types.POSITION, value: '$' });\n","const util      = require('./util');\nconst types     = require('./types');\nconst sets      = require('./sets');\nconst positions = require('./positions');\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n","'use strict';\n/* eslint indent: 4 */\n\n\n// Private helper class\nclass SubRange {\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n        this.length = 1 + high - low;\n    }\n\n    overlaps(range) {\n        return !(this.high < range.low || this.low > range.high);\n    }\n\n    touches(range) {\n        return !(this.high + 1 < range.low || this.low - 1 > range.high);\n    }\n\n    // Returns inclusive combination of SubRanges as a SubRange.\n    add(range) {\n        return new SubRange(\n            Math.min(this.low, range.low),\n            Math.max(this.high, range.high)\n        );\n    }\n\n    // Returns subtraction of SubRanges as an array of SubRanges.\n    // (There's a case where subtraction divides it in 2)\n    subtract(range) {\n        if (range.low <= this.low && range.high >= this.high) {\n            return [];\n        } else if (range.low > this.low && range.high < this.high) {\n            return [\n                new SubRange(this.low, range.low - 1),\n                new SubRange(range.high + 1, this.high)\n            ];\n        } else if (range.low <= this.low) {\n            return [new SubRange(range.high + 1, this.high)];\n        } else {\n            return [new SubRange(this.low, range.low - 1)];\n        }\n    }\n\n    toString() {\n        return this.low == this.high ?\n            this.low.toString() : this.low + '-' + this.high;\n    }\n}\n\n\nclass DRange {\n    constructor(a, b) {\n        this.ranges = [];\n        this.length = 0;\n        if (a != null) this.add(a, b);\n    }\n\n    _update_length() {\n        this.length = this.ranges.reduce((previous, range) => {\n            return previous + range.length;\n        }, 0);\n    }\n\n    add(a, b) {\n        var _add = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.touches(this.ranges[i])) {\n                i++;\n            }\n            var newRanges = this.ranges.slice(0, i);\n            while (i < this.ranges.length && subrange.touches(this.ranges[i])) {\n                subrange = subrange.add(this.ranges[i]);\n                i++;\n            }\n            newRanges.push(subrange);\n            this.ranges = newRanges.concat(this.ranges.slice(i));\n            this._update_length();\n        }\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_add);\n        } else {\n            if (b == null) b = a;\n            _add(new SubRange(a, b));\n        }\n        return this;\n    }\n\n    subtract(a, b) {\n        var _subtract = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {\n                i++;\n            }\n            var newRanges = this.ranges.slice(0, i);\n            while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {\n                newRanges = newRanges.concat(this.ranges[i].subtract(subrange));\n                i++;\n            }\n            this.ranges = newRanges.concat(this.ranges.slice(i));\n            this._update_length();\n        };\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_subtract);\n        } else {\n            if (b == null) b = a;\n            _subtract(new SubRange(a, b));\n        }\n        return this;\n    }\n\n    intersect(a, b) {\n        var newRanges = [];\n        var _intersect = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {\n                i++;\n            }\n            while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {\n                var low = Math.max(this.ranges[i].low, subrange.low);\n                var high = Math.min(this.ranges[i].high, subrange.high);\n                newRanges.push(new SubRange(low, high));\n                i++;\n            }\n        };\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_intersect);\n        } else {\n            if (b == null) b = a;\n            _intersect(new SubRange(a, b));\n        }\n        this.ranges = newRanges;\n        this._update_length();\n        return this;\n    }\n\n    index(index) {\n        var i = 0;\n        while (i < this.ranges.length && this.ranges[i].length <= index) {\n            index -= this.ranges[i].length;\n            i++;\n        }\n        return this.ranges[i].low + index;\n    }\n\n    toString() {\n        return '[ ' + this.ranges.join(', ') + ' ]';\n    }\n\n    clone() {\n        return new DRange(this);\n    }\n\n    numbers() {\n        return this.ranges.reduce((result, subrange) => {\n            var i = subrange.low;\n            while (i <= subrange.high) {\n                result.push(i);\n                i++;\n            }\n            return result;\n        }, []);\n    }\n\n    subranges() {\n        return this.ranges.map((subrange) => ({\n            low: subrange.low,\n            high: subrange.high,\n            length: 1 + subrange.high - subrange.low\n        }));\n    }\n}\n\nmodule.exports = DRange;\n","const ret    = require('ret');\nconst DRange = require('drange');\nconst types  = ret.types;\n\n\nmodule.exports = class RandExp {\n  /**\n   * @constructor\n   * @param {RegExp|String} regexp\n   * @param {String} m\n   */\n  constructor(regexp, m) {\n    this._setDefaults(regexp);\n    if (regexp instanceof RegExp) {\n      this.ignoreCase = regexp.ignoreCase;\n      this.multiline = regexp.multiline;\n      regexp = regexp.source;\n\n    } else if (typeof regexp === 'string') {\n      this.ignoreCase = m && m.indexOf('i') !== -1;\n      this.multiline = m && m.indexOf('m') !== -1;\n    } else {\n      throw new Error('Expected a regexp or string');\n    }\n\n    this.tokens = ret(regexp);\n  }\n\n\n  /**\n   * Checks if some custom properties have been set for this regexp.\n   *\n   * @param {RandExp} randexp\n   * @param {RegExp} regexp\n   */\n  _setDefaults(regexp) {\n    // When a repetitional token has its max set to Infinite,\n    // randexp won't actually generate a random amount between min and Infinite\n    // instead it will see Infinite as min + 100.\n    this.max = regexp.max != null ? regexp.max :\n      RandExp.prototype.max != null ? RandExp.prototype.max : 100;\n\n    // This allows expanding to include additional characters\n    // for instance: RandExp.defaultRange.add(0, 65535);\n    this.defaultRange = regexp.defaultRange ?\n      regexp.defaultRange : this.defaultRange.clone();\n\n    if (regexp.randInt) {\n      this.randInt = regexp.randInt;\n    }\n  }\n\n\n  /**\n   * Generates the random string.\n   *\n   * @return {String}\n   */\n  gen() {\n    return this._gen(this.tokens, []);\n  }\n\n\n  /**\n   * Generate random string modeled after given tokens.\n   *\n   * @param {Object} token\n   * @param {Array.<String>} groups\n   * @return {String}\n   */\n  _gen(token, groups) {\n    var stack, str, n, i, l;\n\n    switch (token.type) {\n      case types.ROOT:\n      case types.GROUP:\n        // Ignore lookaheads for now.\n        if (token.followedBy || token.notFollowedBy) { return ''; }\n\n        // Insert placeholder until group string is generated.\n        if (token.remember && token.groupNumber === undefined) {\n          token.groupNumber = groups.push(null) - 1;\n        }\n\n        stack = token.options ?\n          this._randSelect(token.options) : token.stack;\n\n        str = '';\n        for (i = 0, l = stack.length; i < l; i++) {\n          str += this._gen(stack[i], groups);\n        }\n\n        if (token.remember) {\n          groups[token.groupNumber] = str;\n        }\n        return str;\n\n      case types.POSITION:\n        // Do nothing for now.\n        return '';\n\n      case types.SET:\n        var expandedSet = this._expand(token);\n        if (!expandedSet.length) { return ''; }\n        return String.fromCharCode(this._randSelect(expandedSet));\n\n      case types.REPETITION:\n        // Randomly generate number between min and max.\n        n = this.randInt(token.min,\n          token.max === Infinity ? token.min + this.max : token.max);\n\n        str = '';\n        for (i = 0; i < n; i++) {\n          str += this._gen(token.value, groups);\n        }\n\n        return str;\n\n      case types.REFERENCE:\n        return groups[token.value - 1] || '';\n\n      case types.CHAR:\n        var code = this.ignoreCase && this._randBool() ?\n          this._toOtherCase(token.value) : token.value;\n        return String.fromCharCode(code);\n    }\n  }\n\n\n  /**\n   * If code is alphabetic, converts to other case.\n   * If not alphabetic, returns back code.\n   *\n   * @param {Number} code\n   * @return {Number}\n   */\n  _toOtherCase(code) {\n    return code + (97 <= code && code <= 122 ? -32 :\n      65 <= code && code <= 90  ?  32 : 0);\n  }\n\n\n  /**\n   * Randomly returns a true or false value.\n   *\n   * @return {Boolean}\n   */\n  _randBool() {\n    return !this.randInt(0, 1);\n  }\n\n\n  /**\n   * Randomly selects and returns a value from the array.\n   *\n   * @param {Array.<Object>} arr\n   * @return {Object}\n   */\n  _randSelect(arr) {\n    if (arr instanceof DRange) {\n      return arr.index(this.randInt(0, arr.length - 1));\n    }\n    return arr[this.randInt(0, arr.length - 1)];\n  }\n\n\n  /**\n   * expands a token to a DiscontinuousRange of characters which has a\n   * length and an index function (for random selecting)\n   *\n   * @param {Object} token\n   * @return {DiscontinuousRange}\n   */\n  _expand(token) {\n    if (token.type === ret.types.CHAR) {\n      return new DRange(token.value);\n    } else if (token.type === ret.types.RANGE) {\n      return new DRange(token.from, token.to);\n    } else {\n      let drange = new DRange();\n      for (let i = 0; i < token.set.length; i++) {\n        let subrange = this._expand(token.set[i]);\n        drange.add(subrange);\n        if (this.ignoreCase) {\n          for (let j = 0; j < subrange.length; j++) {\n            let code = subrange.index(j);\n            let otherCaseCode = this._toOtherCase(code);\n            if (code !== otherCaseCode) {\n              drange.add(otherCaseCode);\n            }\n          }\n        }\n      }\n      if (token.not) {\n        return this.defaultRange.clone().subtract(drange);\n      } else {\n        return this.defaultRange.clone().intersect(drange);\n      }\n    }\n  }\n\n\n  /**\n   * Randomly generates and returns a number between a and b (inclusive).\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @return {Number}\n   */\n  randInt(a, b) {\n    return a + Math.floor(Math.random() * (1 + b - a));\n  }\n\n\n  /**\n   * Default range of characters to generate from.\n   */\n  get defaultRange() {\n    return this._range = this._range || new DRange(32, 126);\n  }\n\n  set defaultRange(range) {\n    this._range = range;\n  }\n\n\n  /**\n   *\n   * Enables use of randexp with a shorter call.\n   *\n   * @param {RegExp|String| regexp}\n   * @param {String} m\n   * @return {String}\n   */\n  static randexp(regexp, m) {\n    var randexp;\n    if(typeof regexp === 'string') {\n      regexp = new RegExp(regexp, m);\n    }\n\n    if (regexp._randexp === undefined) {\n      randexp = new RandExp(regexp, m);\n      regexp._randexp = randexp;\n    } else {\n      randexp = regexp._randexp;\n      randexp._setDefaults(regexp);\n    }\n    return randexp.gen();\n  }\n\n\n  /**\n   * Enables sugary /regexp/.gen syntax.\n   */\n  static sugar() {\n    /* eshint freeze:false */\n    RegExp.prototype.gen = function() {\n      return RandExp.randexp(this);\n    };\n  }\n};\n","'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n","var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    arrayMap = require('./_arrayMap'),\n    baseUnary = require('./_baseUnary'),\n    cacheHas = require('./_cacheHas');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseDifference;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var isArrayLike = require('./isArrayLike'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n","var baseDifference = require('./_baseDifference'),\n    baseFlatten = require('./_baseFlatten'),\n    baseRest = require('./_baseRest'),\n    isArrayLikeObject = require('./isArrayLikeObject');\n\n/**\n * Creates an array of `array` values not included in the other given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([2, 1], [2, 3]);\n * // => [1]\n */\nvar difference = baseRest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n    : [];\n});\n\nmodule.exports = difference;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    arrayMap = require('./_arrayMap'),\n    baseUnary = require('./_baseUnary'),\n    cacheHas = require('./_cacheHas');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * The base implementation of methods like `_.intersection`, without support\n * for iteratee shorthands, that accepts an array of arrays to inspect.\n *\n * @private\n * @param {Array} arrays The arrays to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of shared values.\n */\nfunction baseIntersection(arrays, iteratee, comparator) {\n  var includes = comparator ? arrayIncludesWith : arrayIncludes,\n      length = arrays[0].length,\n      othLength = arrays.length,\n      othIndex = othLength,\n      caches = Array(othLength),\n      maxLength = Infinity,\n      result = [];\n\n  while (othIndex--) {\n    var array = arrays[othIndex];\n    if (othIndex && iteratee) {\n      array = arrayMap(array, baseUnary(iteratee));\n    }\n    maxLength = nativeMin(array.length, maxLength);\n    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n      ? new SetCache(othIndex && array)\n      : undefined;\n  }\n  array = arrays[0];\n\n  var index = -1,\n      seen = caches[0];\n\n  outer:\n  while (++index < length && result.length < maxLength) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (!(seen\n          ? cacheHas(seen, computed)\n          : includes(result, computed, comparator)\n        )) {\n      othIndex = othLength;\n      while (--othIndex) {\n        var cache = caches[othIndex];\n        if (!(cache\n              ? cacheHas(cache, computed)\n              : includes(arrays[othIndex], computed, comparator))\n            ) {\n          continue outer;\n        }\n      }\n      if (seen) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseIntersection;\n","var isArrayLikeObject = require('./isArrayLikeObject');\n\n/**\n * Casts `value` to an empty array if it's not an array like object.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array|Object} Returns the cast array-like object.\n */\nfunction castArrayLikeObject(value) {\n  return isArrayLikeObject(value) ? value : [];\n}\n\nmodule.exports = castArrayLikeObject;\n","var arrayMap = require('./_arrayMap'),\n    baseIntersection = require('./_baseIntersection'),\n    baseRest = require('./_baseRest'),\n    castArrayLikeObject = require('./_castArrayLikeObject');\n\n/**\n * Creates an array of unique values that are included in all given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * _.intersection([2, 1], [2, 3]);\n * // => [2]\n */\nvar intersection = baseRest(function(arrays) {\n  var mapped = arrayMap(arrays, castArrayLikeObject);\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped)\n    : [];\n});\n\nmodule.exports = intersection;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n","var assignMergeValue = require('./_assignMergeValue'),\n    cloneBuffer = require('./_cloneBuffer'),\n    cloneTypedArray = require('./_cloneTypedArray'),\n    copyArray = require('./_copyArray'),\n    initCloneObject = require('./_initCloneObject'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLikeObject = require('./isArrayLikeObject'),\n    isBuffer = require('./isBuffer'),\n    isFunction = require('./isFunction'),\n    isObject = require('./isObject'),\n    isPlainObject = require('./isPlainObject'),\n    isTypedArray = require('./isTypedArray'),\n    safeGet = require('./_safeGet'),\n    toPlainObject = require('./toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n","var Stack = require('./_Stack'),\n    assignMergeValue = require('./_assignMergeValue'),\n    baseFor = require('./_baseFor'),\n    baseMergeDeep = require('./_baseMergeDeep'),\n    isObject = require('./isObject'),\n    keysIn = require('./keysIn'),\n    safeGet = require('./_safeGet');\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var baseMerge = require('./_baseMerge'),\n    createAssigner = require('./_createAssigner');\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n","var baseMerge = require('./_baseMerge'),\n    createAssigner = require('./_createAssigner');\n\n/**\n * This method is like `_.merge` except that it accepts `customizer` which\n * is invoked to produce the merged values of the destination and source\n * properties. If `customizer` returns `undefined`, merging is handled by the\n * method instead. The `customizer` is invoked with six arguments:\n * (objValue, srcValue, key, object, source, stack).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   if (_.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * }\n *\n * var object = { 'a': [1], 'b': [2] };\n * var other = { 'a': [3], 'b': [4] };\n *\n * _.mergeWith(object, other, customizer);\n * // => { 'a': [1, 3], 'b': [2, 4] }\n */\nvar mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n  baseMerge(object, source, srcIndex, customizer);\n});\n\nmodule.exports = mergeWith;\n","var assignValue = require('./_assignValue'),\n    castPath = require('./_castPath'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nmodule.exports = baseSet;\n","var baseSet = require('./_baseSet');\n\n/**\n * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n * it's created. Arrays are created for missing index properties while objects\n * are created for all other missing properties. Use `_.setWith` to customize\n * `path` creation.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.set(object, 'a[0].b.c', 4);\n * console.log(object.a[0].b.c);\n * // => 4\n *\n * _.set(object, ['x', '0', 'y', 'z'], 5);\n * console.log(object.x[0].y.z);\n * // => 5\n */\nfunction set(object, path, value) {\n  return object == null ? object : baseSet(object, path, value);\n}\n\nmodule.exports = set;\n","import type { SchemaValidationErrorType } from '.'\nimport type { JsfSchemaType, NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { randexp } from 'randexp'\nimport { convertKBToMB } from '../utils'\nimport { DATE_FORMAT } from '../validation/custom/date'\n\n/**\n * Check if the schema is a checkbox\n * @param schema - The schema to check\n * @returns True if the schema is a checkbox, false otherwise\n */\nfunction isCheckbox(schema: NonBooleanJsfSchema): boolean {\n  return schema['x-jsf-presentation']?.inputType === 'checkbox'\n}\n\n// Both required and const error messages are the same for checkboxes\nconst CHECKBOX_ACK_ERROR_MESSAGE = 'Please acknowledge this field'\n\nexport function getErrorMessage(\n  schema: NonBooleanJsfSchema,\n  value: SchemaValue,\n  validation: SchemaValidationErrorType,\n  customErrorMessage?: string,\n): string {\n  const presentation = schema['x-jsf-presentation']\n  switch (validation) {\n    // Core validation\n    case 'type':\n      return getTypeErrorMessage(schema.type)\n    case 'required':\n      if (isCheckbox(schema)) {\n        return CHECKBOX_ACK_ERROR_MESSAGE\n      }\n      return 'Required field'\n    case 'forbidden':\n      return 'Not allowed'\n    case 'const':\n      // Boolean checkboxes that are required will come as a \"const\" validation error as the \"empty\" value is false\n      if (isCheckbox(schema) && value === false) {\n        return CHECKBOX_ACK_ERROR_MESSAGE\n      }\n      return `The only accepted value is ${JSON.stringify(schema.const)}.`\n    case 'enum':\n      return `The option \"${valueToString(value)}\" is not valid.`\n    // Schema composition\n    case 'oneOf':\n      return `The option \"${valueToString(value)}\" is not valid.`\n    case 'anyOf':\n      return `The option \"${valueToString(value)}\" is not valid.`\n    case 'not':\n      return 'The value must not satisfy the provided schema'\n    // String validation\n    case 'minLength':\n      return `Please insert at least ${schema.minLength} characters`\n    case 'maxLength':\n      return `Please insert up to ${schema.maxLength} characters`\n    case 'pattern':\n      return `Must have a valid format. E.g. ${randexp(schema.pattern || '')}`\n    case 'format':\n      if (schema.format === 'email') {\n        return 'Please enter a valid email address'\n      }\n\n      if (schema.format === 'date') {\n        const currentDate = new Date().toISOString().split('T')[0]\n        return `Must be a valid date in ${DATE_FORMAT.toLowerCase()} format. e.g. ${currentDate}`\n      }\n\n      return `Must be a valid ${schema.format} format`\n    // Number validation\n    case 'multipleOf':\n      return `Must be a multiple of ${schema.multipleOf}`\n    case 'maximum':\n      return `Must be smaller or equal to ${schema.maximum}`\n    case 'exclusiveMaximum':\n      return `Must be smaller than ${schema.exclusiveMaximum}`\n    case 'minimum':\n      return `Must be greater or equal to ${schema.minimum}`\n    case 'exclusiveMinimum':\n      return `Must be greater than ${schema.exclusiveMinimum}`\n    // Date validation\n    case 'minDate':\n      return `The date must be ${presentation?.minDate} or after.`\n    case 'maxDate':\n      return `The date must be ${presentation?.maxDate} or before.`\n    // File validation\n    case 'fileStructure':\n      return 'Not a valid file.'\n    case 'maxFileSize': {\n      const limitKB = presentation?.maxFileSize\n      const limitMB = typeof limitKB === 'number' ? convertKBToMB(limitKB) : undefined\n      return `File size too large.${limitMB ? ` The limit is ${limitMB} MB.` : ''}`\n    }\n    case 'accept': {\n      const formats = presentation?.accept\n      return `Unsupported file format.${formats ? ` The acceptable formats are ${formats}.` : ''}`\n    }\n    // Arrays\n    case 'minItems': {\n      const itemOrItems = schema.minItems === 1 ? 'item' : 'items'\n      return `Must have at least ${schema.minItems} ${itemOrItems}`\n    }\n    case 'maxItems': {\n      const itemOrItems = schema.maxItems === 1 ? 'item' : 'items'\n      return `Must have at most ${schema.maxItems} ${itemOrItems}`\n    }\n    case 'uniqueItems':\n      return 'Items must be unique'\n    case 'contains':\n      throw new Error('\"contains\" is not implemented yet')\n    case 'minContains':\n      throw new Error('\"minContains\" is not implemented yet')\n    case 'maxContains':\n      throw new Error('\"maxContains\" is not implemented yet')\n    case 'additionalProperties':\n      return 'Additional property is not allowed'\n    case 'json-logic':\n      return customErrorMessage || 'The value is not valid'\n  }\n}\n\n/**\n * Get the appropriate type error message based on the schema type\n */\nfunction getTypeErrorMessage(schemaType: JsfSchemaType | JsfSchemaType[] | undefined): string {\n  if (Array.isArray(schemaType)) {\n    // Map 'integer' to 'number' in error messages\n    const formattedTypes = schemaType.map((type) => {\n      if (type === 'integer') {\n        return 'number'\n      }\n      return type\n    })\n\n    return `The value must be a ${formattedTypes.join(' or ')}`\n  }\n\n  switch (schemaType) {\n    case 'number':\n    case 'integer':\n      return 'The value must be a number'\n    case 'boolean':\n      return 'The value must be a boolean'\n    case 'null':\n      return 'The value must be null'\n    case 'string':\n      return 'The value must be a string'\n    case 'object':\n      return 'The value must be an object'\n    case 'array':\n      return 'The value must be an array'\n    default:\n      return schemaType ? `The value must be ${schemaType}` : 'Invalid value'\n  }\n}\n\nfunction valueToString(value: SchemaValue): string {\n  if (typeof value === 'string') {\n    return value\n  }\n  return JSON.stringify(value)\n}\n","import type { Field } from './field/type'\n\ntype DiskSizeUnit = 'Bytes' | 'KB' | 'MB'\n\n/**\n * @todo: Remove this.\n *\n * This utility only exists as an example of using V1 tests for V2 source.\n * It should not be tested, or even part of JSON Schema Form.\n */\nexport function convertDiskSizeFromTo(\n  from: DiskSizeUnit,\n  to: DiskSizeUnit,\n): (value: number) => number {\n  const multipliers: Record<DiskSizeUnit, number> = {\n    Bytes: 1,\n    KB: 1024,\n    MB: 1024 * 1024,\n  }\n\n  return (value: number): number => {\n    const fromMultiplier = multipliers[from]\n    const toMultiplier = multipliers[to]\n    return (value * fromMultiplier) / toMultiplier\n  }\n}\n\n/**\n * Get a field from a list of fields by name.\n * If the field is nested, you can pass additional names to access a nested field.\n * @param fields - The list of fields to search in.\n * @param name - The name of the field to search for.\n * @param subNames - The names of the nested fields to access.\n * @returns The field if found, otherwise undefined.\n */\nexport function getField(fields: Field[], name: string, ...subNames: string[]) {\n  const field = fields.find(f => f.name === name)\n  if (subNames.length) {\n    if (!field?.fields) {\n      return undefined\n    }\n    return getField(field.fields, subNames[0], ...subNames.slice(1))\n  }\n  return field\n}\n\n// Helper function to convert KB to MB\nexport function convertKBToMB(kb: number): number {\n  if (kb === 0) {\n    return 0\n  }\n  const mb = kb / 1024 // KB to MB\n  return Number.parseFloat(mb.toFixed(2)) // Keep 2 decimal places\n}\n\n// When merging schemas, we should skip merging the if/then/else properties as we could be creating wrong conditions\nconst KEYS_TO_SKIP = ['if', 'then', 'else']\n\nfunction isObject(value: any): boolean {\n  return value && typeof value === 'object' && !Array.isArray(value)\n}\n\n/**\n * Merges schema 2 into schema 1 recursively\n * @param schema1 - The first schema to merge\n * @param schema2 - The second schema to merge\n */\nexport function deepMergeSchemas<T extends Record<string, any>>(schema1: T, schema2: T): void {\n  // Handle null/undefined values\n  if (!schema1 || !schema2) {\n    return\n  }\n\n  // Handle non-objects\n  if (typeof schema1 !== 'object' || typeof schema2 !== 'object') {\n    return\n  }\n\n  // Merge all properties from schema2 into schema1\n  for (const [key, schema2Value] of Object.entries(schema2)) {\n    // let's skip merging some properties\n    if (KEYS_TO_SKIP.includes(key)) {\n      continue\n    }\n\n    const schema1Value = schema1[key]\n\n    // If the value is an object:\n    if (isObject(schema2Value)) {\n      // If both schemas have this key and it's an object, merge recursively\n      if (isObject(schema1Value)) {\n        deepMergeSchemas(schema1Value, schema2Value)\n      }\n      // Otherwise, if the value is different, just assign it\n      else if (schema1Value !== schema2Value) {\n        schema1[key as keyof T] = schema2Value\n      }\n    }\n    // If the value is an array, cycle through it and merge values if they're different (take objects into account)\n    else if (schema1Value && Array.isArray(schema2Value)) {\n      const originalArray = schema1Value\n      // If the destiny value exists and it's an array, cycle through the incoming values and merge if they're different (take objects into account)\n      for (const item of schema2Value) {\n        if (item && typeof item === 'object') {\n          deepMergeSchemas(originalArray, schema2Value)\n        }\n        // \"required\" is a special case, it only allows for new elements to be added to the array\n        else if (key === 'required') {\n          // Add any new elements to the array\n          if (!originalArray.find((originalItem: any) => originalItem === item)) {\n            originalArray.push(item)\n          }\n        }\n        // Otherwise, just assign it\n        else {\n          schema1[key as keyof T] = schema2Value as T[keyof T]\n        }\n      }\n    }\n    // Finally, if the value is different, just assign it\n    else if (schema1[key] !== schema2Value) {\n      schema1[key as keyof T] = schema2Value\n    }\n  }\n}\n","import type { ValidationError, ValidationErrorPath } from '../../errors'\nimport type { NonBooleanJsfSchema, SchemaValue } from '../../types'\nimport type { LegacyOptions } from '../schema'\n\nexport const DATE_FORMAT = 'yyyy-MM-dd'\ntype DateComparisonResult = 'LESSER' | 'GREATER' | 'EQUAL'\n\n/**\n * Compare two dates and returns the ComparisonResult (LESSER, GREATER, EQUAL)\n * @param d1 - The first date\n * @param d2 - The second date\n * @returns 'LESSER' if the first date is less than the second date, 'GREATER' if the first date is greater than the second date, 'EQUAL' if the two dates are equal\n */\nfunction compareDates(d1: string, d2: string): DateComparisonResult {\n  const date1 = new Date(d1).getTime()\n  const date2 = new Date(d2).getTime()\n\n  if (date1 < date2) {\n    return 'LESSER'\n  }\n  else if (date1 > date2) {\n    return 'GREATER'\n  }\n  else {\n    return 'EQUAL'\n  }\n};\n\n/**\n * Validate that a date value is greater than or equal to the minimum date\n * @param value - The value to validate\n * @param minDate - The minimum date to validate against\n * @returns true if the date is greater than or equal to the minimum date, false otherwise\n */\nfunction validateMinDate(value: string, minDate: string): boolean {\n  const result = compareDates(value, minDate)\n  return result === 'GREATER' || result === 'EQUAL'\n};\n\n/**\n * Validate that a date value is less than or equal to the maximum date\n * @param value - The value to validate\n * @param maxDate - The maximum date to validate against\n * @returns true if the date is less than or equal to the maximum date, false otherwise\n */\nfunction validateMaxDate(value: string, maxDate: string): boolean {\n  const result = compareDates(value, maxDate)\n\n  return result === 'LESSER' || result === 'EQUAL'\n};\n\n/**\n * Validate that a date value is valid\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param options - The validation options\n * @param path - The path to the value\n * @returns An array of validation errors\n * @description This function validates that a date string value matches the maximum\n * and minimum date set in the x-jsf-presentation property.\n */\nexport function validateDate(\n  value: SchemaValue,\n  schema: NonBooleanJsfSchema,\n  options: LegacyOptions,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  const isString = typeof value === 'string'\n  const isEmptyString = value === ''\n  const isUndefined = value === undefined || (value === null && options.treatNullAsUndefined)\n  const isEmpty = isEmptyString || isUndefined\n  const errors: ValidationError[] = []\n\n  if (!isString || isEmpty || schema['x-jsf-presentation'] === undefined) {\n    return errors\n  }\n\n  const { minDate, maxDate } = schema['x-jsf-presentation']\n\n  if (minDate && !validateMinDate(value, minDate)) {\n    errors.push({ path, validation: 'minDate', schema, value })\n  }\n\n  if (maxDate && !validateMaxDate(value, maxDate)) {\n    errors.push({ path, validation: 'maxDate', schema, value })\n  }\n\n  return errors\n}\n","import type { AsyncOptionsLoader, JsfObjectSchema, JsfSchema, JsfSchemaType, NonBooleanJsfSchema, ObjectValue, SchemaValue } from '../types'\nimport type { Field, FieldOption, FieldType } from './type'\nimport deepmerge from 'deepmerge'\nimport { setCustomOrder } from '../custom/order'\n\n/**\n * Add checkbox attributes to a field\n * @param inputType - The input type of the field\n * @param field - The field to add the attributes to\n * @param schema - The schema of the field\n */\nfunction addCheckboxAttributes(inputType: string, field: Field, schema: NonBooleanJsfSchema) {\n  // The checkboxValue attribute indicates which is the valid value a checkbox can have (for example \"acknowledge\", or `true`)\n  // So, we set it to what's specified in the schema (if any)\n  field.checkboxValue = schema.const\n\n  // However, if the schema type is boolean, we should set the valid value as `true`\n  if (Array.isArray(schema.type) ? schema.type.includes('boolean') : schema.type === 'boolean') {\n    field.checkboxValue = true\n  }\n}\n\n/**\n * Add options attribute to a field\n * @param field - The field to add the options to\n * @param schema - The schema of the field\n * @description\n * This adds the options attribute to based on the schema's oneOf, anyOf, or enum if we don't already have options on the field.\n */\nfunction addOptions(field: Field, schema: NonBooleanJsfSchema) {\n  if (field.options === undefined) {\n    const options = getFieldOptions(schema)\n    if (options) {\n      field.options = options\n      if (schema.type === 'array') {\n        field.multiple = true\n      }\n    }\n  }\n}\n\n/**\n * Add fields attribute to a field\n * @param field - The field to add the fields to\n * @param schema - The schema of the field\n * @param originalSchema - The original schema (needed for calculating the original input type on conditionally hidden fields)\n * @param strictInputType - Whether to strictly enforce the input type\n * @param asyncLoaders - Optional map of async option loaders\n * @param formValues - Current form values for dependent async options\n * @description\n * This adds the fields attribute to based on the schema's items.\n * Since options and fields are mutually exclusive, we only add fields if no options were provided.\n */\nfunction addFields(\n  field: Field,\n  schema: NonBooleanJsfSchema,\n  originalSchema: JsfSchema,\n  strictInputType?: boolean,\n  asyncLoaders?: Record<string, AsyncOptionsLoader>,\n  formValues?: ObjectValue,\n) {\n  if (field.options === undefined && field.asyncOptions === undefined) {\n    const fields = getFields(schema, originalSchema, strictInputType, asyncLoaders, formValues)\n    if (fields) {\n      field.fields = fields\n    }\n  }\n}\n\n/**\n * Get the presentation input type for a field from a schema type (ported from v0)\n * @param type - The schema type\n * @param schema - The non boolean schema of the field\n * @returns The input type for the field, based schema type. Default to 'text'\n */\nfunction getInputTypeFromSchema(type: JsfSchemaType, schema: NonBooleanJsfSchema): FieldType {\n  if (!type) {\n    return 'text'\n  }\n\n  switch (type) {\n    case 'string': {\n      const { oneOf, format } = schema\n      if (format === 'email') {\n        return 'email'\n      }\n      if (format === 'date') {\n        return 'date'\n      }\n      if (format === 'data-url') {\n        return 'file'\n      }\n      if (oneOf) {\n        return 'radio'\n      }\n      return 'text'\n    }\n    case 'number':\n    case 'integer':\n      return 'number'\n    case 'object':\n      return 'fieldset'\n    case 'array': {\n      const { items } = schema\n      if (items?.properties) {\n        return 'group-array'\n      }\n      return 'select'\n    }\n    case 'boolean':\n      return 'checkbox'\n    default:\n      return 'text'\n  }\n}\n\n/**\n * Get the input type for a field\n * @param type - The schema type\n * @param name - The name of the field\n * @param schema - The non boolean schema of the field\n * @param strictInputType - Whether to strictly enforce the input type\n * @returns The input type for the field, based schema type. Default to 'text'\n * @throws If the input type is missing and strictInputType is true with the exception of the root field\n */\nexport function getInputType(type: JsfSchemaType, name: string, schema: NonBooleanJsfSchema, strictInputType?: boolean): FieldType {\n  const presentation = schema['x-jsf-presentation']\n  if (presentation?.inputType) {\n    return presentation.inputType as FieldType\n  }\n\n  if (strictInputType && name !== 'root') {\n    throw new Error(`Strict error: Missing inputType to field \"${schema.title}\".\nYou can fix the json schema or skip this error by calling createHeadlessForm(schema, { strictInputType: false })`)\n  }\n\n  // If root schema has no type\n  if (!schema.type) {\n    // Check if it has an \"items\" value with properties\n    if (schema.items?.properties) {\n      return 'group-array'\n    }\n\n    // Check if it has a \"properties\" value\n    if (schema.properties) {\n      return 'select'\n    }\n  }\n\n  // Get input type from schema (fallback type is \"string\")\n  return getInputTypeFromSchema(type || schema.type || 'string', schema)\n}\n\n/**\n * Convert options to the required format\n * This is used when we have a oneOf or anyOf schema property\n * @param nodeOptions - The options to convert - the oneOf/anyOf elements in a schema\n * @returns The converted options\n * @description\n * The options are converted to the required format by checking if the option has a const property.\n * If it does, we add the option to the options array.\n * If it doesn't, we skip the option.\n */\nfunction convertToOptions(nodeOptions: JsfSchema[]): Array<FieldOption> {\n  return nodeOptions\n    .filter((option): option is NonBooleanJsfSchema =>\n      option !== null && typeof option === 'object' && option.const !== null,\n    )\n    .map((schemaOption) => {\n      const title = schemaOption.title\n      const value = schemaOption.const\n      const presentation = typeof schemaOption['x-jsf-presentation'] === 'object' ? schemaOption['x-jsf-presentation'] : {}\n\n      const result: {\n        label: string\n        value: unknown\n        [key: string]: unknown\n      } = {\n        label: title || '',\n        value,\n      }\n\n      // Add other properties, without known ones we already handled above\n      const { title: _, const: __, 'x-jsf-presentation': ___, ...rest } = schemaOption\n\n      return { ...result, ...presentation, ...rest }\n    })\n}\n\n/**\n * Get field options from schema\n */\nfunction getFieldOptions(schema: NonBooleanJsfSchema) {\n  if (schema.oneOf) {\n    return convertToOptions(schema.oneOf || [])\n  }\n\n  // Handle items.anyOf (for multiple select)\n  if (schema.items?.anyOf) {\n    return convertToOptions(schema.items.anyOf)\n  }\n\n  // Handle anyOf\n  if (schema.anyOf) {\n    return convertToOptions(schema.anyOf)\n  }\n\n  // Handle enum\n  if (schema.enum) {\n    const enumAsOneOf: JsfSchema['oneOf'] = schema.enum?.map(value => ({\n      title: typeof value === 'string' ? value : JSON.stringify(value),\n      const: value as SchemaValue,\n    })) || []\n    return convertToOptions(enumAsOneOf)\n  }\n\n  return null\n}\n\n/**\n * Get the fields for an object schema\n * @param schema - The schema of the field\n * @param originalSchema - The original schema (needed for calculating the original input type on conditionally hidden fields)\n * @param strictInputType - Whether to strictly enforce the input type\n * @param asyncLoaders - Optional map of async option loaders\n * @param formValues - Current form values for dependent async options\n * @returns The fields for the schema or an empty array if the schema does not define any properties\n */\nfunction getObjectFields(\n  schema: NonBooleanJsfSchema,\n  originalSchema: NonBooleanJsfSchema,\n  strictInputType?: boolean,\n  asyncLoaders?: Record<string, AsyncOptionsLoader>,\n  formValues?: ObjectValue,\n): Field[] | null {\n  const fields: Field[] = []\n\n  for (const key in schema.properties) {\n    const isRequired = schema.required?.includes(key) || false\n    const field = buildFieldSchema({\n      schema: schema.properties[key],\n      name: key,\n      required: isRequired,\n      originalSchema: originalSchema.properties?.[key] || schema.properties[key],\n      strictInputType,\n      asyncLoaders,\n      formValues,\n    })\n    if (field) {\n      fields.push(field)\n    }\n  }\n\n  const orderedFields = setCustomOrder(schema, fields)\n\n  return orderedFields\n}\n\n/**\n * Get the fields for an array schema\n * @param schema - The schema of the field\n * @param originalSchema - The original schema (needed for calculating the original input type on conditionally hidden fields)\n * @param strictInputType - Whether to strictly enforce the input type\n * @param asyncLoaders - Optional map of async option loaders\n * @param formValues - Current form values for dependent async options\n * @returns The fields for the schema or an empty array if the schema does not define any items\n */\nfunction getArrayFields(\n  schema: NonBooleanJsfSchema,\n  originalSchema: NonBooleanJsfSchema,\n  strictInputType?: boolean,\n  asyncLoaders?: Record<string, AsyncOptionsLoader>,\n  formValues?: ObjectValue,\n): Field[] {\n  const fields: Field[] = []\n\n  if (typeof schema.items !== 'object' || schema.items === null) {\n    return []\n  }\n\n  if (schema.items?.type === 'object') {\n    const objectSchema = schema.items as JsfObjectSchema\n\n    for (const key in objectSchema.properties) {\n      const isFieldRequired = objectSchema.required?.includes(key) || false\n      const field = buildFieldSchema({\n        schema: objectSchema.properties[key],\n        name: key,\n        required: isFieldRequired,\n        originalSchema,\n        strictInputType,\n        asyncLoaders,\n        formValues,\n      })\n      if (field) {\n        field.nameKey = key\n        fields.push(field)\n      }\n    }\n  }\n  else {\n    const field = buildFieldSchema({\n      schema: schema.items,\n      name: 'item',\n      required: false,\n      originalSchema,\n      strictInputType,\n      asyncLoaders,\n      formValues,\n    })\n    if (field) {\n      fields.push(field)\n    }\n  }\n\n  const orderedFields = setCustomOrder(schema.items, fields)\n\n  return orderedFields\n}\n\n/**\n * Get the fields for a schema from either `items` or `properties`\n * @param schema - The schema of the field\n * @param originalSchema - The original schema (needed for calculating the original input type on conditionally hidden fields)\n * @param strictInputType - Whether to strictly enforce the input type\n * @param asyncLoaders - Optional map of async option loaders\n * @param formValues - Current form values for dependent async options\n * @returns The fields for the schema\n */\nfunction getFields(\n  schema: NonBooleanJsfSchema,\n  originalSchema: NonBooleanJsfSchema,\n  strictInputType?: boolean,\n  asyncLoaders?: Record<string, AsyncOptionsLoader>,\n  formValues?: ObjectValue,\n): Field[] | null {\n  if (typeof schema.properties === 'object' && schema.properties !== null) {\n    return getObjectFields(schema, originalSchema, strictInputType, asyncLoaders, formValues)\n  }\n  else if (typeof schema.items === 'object' && schema.items !== null) {\n    return getArrayFields(schema, originalSchema, strictInputType, asyncLoaders, formValues)\n  }\n\n  return null\n}\n\n/**\n * List of schema properties that should be excluded from the final field or handled specially\n */\nconst excludedSchemaProps = [\n  'title', // Transformed to 'label'\n  'type', // Handled separately\n  'x-jsf-errorMessage', // Handled separately\n  'x-jsf-presentation', // Handled separately\n  'x-jsf-layout', // Handled separately\n  'oneOf', // Transformed to 'options'\n  'anyOf', // Transformed to 'options'\n  'properties', // Handled separately\n]\n\ninterface BuildFieldSchemaParams {\n  schema: JsfSchema\n  name: string\n  required?: boolean\n  originalSchema: NonBooleanJsfSchema\n  strictInputType?: boolean\n  type?: JsfSchemaType\n  asyncLoaders?: Record<string, AsyncOptionsLoader>\n  formValues?: ObjectValue\n}\n\n/**\n * Build a field from any schema\n * @param params - The parameters for building the field\n * @param params.schema - The schema of the field\n * @param params.name - The name of the field\n * @param params.required - Whether the field is required\n * @param params.originalSchema - The original schema (needed for calculating the original input type on conditionally hidden fields)\n * @param params.strictInputType - Whether to strictly enforce the input type\n * @param params.type - The schema type\n * @param params.asyncLoaders - Optional map of async option loaders\n * @param params.formValues - Current form values for dependent async options\n * @returns The field\n */\nexport function buildFieldSchema({\n  schema,\n  name,\n  required = false,\n  originalSchema,\n  strictInputType = false,\n  type = undefined,\n  asyncLoaders = {},\n  formValues = {},\n}: BuildFieldSchemaParams): Field | null {\n  // If schema is boolean false, return a field with isVisible=false\n  if (schema === false) {\n    // If the schema is false (hidden field), we use the original schema to get the input type\n    const inputType = getInputType(type, name, originalSchema, strictInputType)\n    const inputHasInnerFields = ['fieldset', 'group-array'].includes(inputType)\n\n    return {\n      type: inputType,\n      name,\n      inputType,\n      jsonType: 'boolean',\n      required,\n      isVisible: false,\n      ...(inputHasInnerFields && { fields: [] }),\n    }\n  }\n\n  // If schema is any other boolean (true), just return null\n  if (typeof schema === 'boolean') {\n    return null\n  }\n\n  // We need to use the original schema's presentation as a basis as there are some properties that can't be\n  // serialized (so they were not cloned). Arrays will always be overwritten by the new schema's presentation.\n  const originalSchemaPresentation = originalSchema['x-jsf-presentation'] || {}\n  const schemaPresentation = schema['x-jsf-presentation'] || {}\n  const presentation = deepmerge(originalSchemaPresentation, schemaPresentation, { arrayMerge: (_destinationArray, sourceArray, _options) => sourceArray })\n  \n  // Handle layout configuration\n  const originalLayoutConfig = originalSchema['x-jsf-layout']\n  const schemaLayoutConfig = schema['x-jsf-layout']\n  const layoutConfig = schemaLayoutConfig || originalLayoutConfig\n  \n  const errorMessage = schema['x-jsf-errorMessage']\n\n  // Get input type from presentation or fallback to schema type\n  const inputType = getInputType(type, name, schema, strictInputType)\n\n  // Build field with all schema properties by default, excluding ones that need special handling\n  const field: Field = {\n    // Spread all schema properties except excluded ones\n    ...Object.entries(schema)\n      .filter(([key]) => !excludedSchemaProps.includes(key))\n      .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {}),\n    // Add required field properties\n    name,\n    inputType,\n    type: inputType,\n    jsonType: type || schema.type,\n    required,\n    isVisible: true,\n    ...(errorMessage && { errorMessage }),\n    ...(layoutConfig && { layout: layoutConfig }),\n  }\n\n  if (inputType === 'checkbox') {\n    addCheckboxAttributes(inputType, field, schema)\n  }\n\n  if (schema.title) {\n    field.label = schema.title\n  }\n\n  // Spread presentation properties to the root level\n  if (Object.keys(presentation).length > 0) {\n    Object.entries(presentation).forEach(([key, value]) => {\n      // inputType and asyncOptions are handled separately\n      if (key === 'inputType' || key === 'asyncOptions') {\n        return\n      }\n\n      field[key] = value\n    })\n  }\n\n  if (name !== 'root') {\n    addOptions(field, schema)\n  }\n\n  // Add async options configuration if present\n  const asyncOptionsConfig = presentation.asyncOptions\n  if (asyncOptionsConfig && asyncOptionsConfig.id) {\n    const loader = asyncLoaders?.[asyncOptionsConfig.id]\n    \n    if (loader !== undefined) {\n      // Expose the loader directly for maximum flexibility\n      field.asyncOptions = {\n        ...asyncOptionsConfig,\n        loader,  // Direct access to the loader function\n      }\n    }\n    else {\n      // If loader is not provided, keep the config but without the bound function\n      // This allows the UI to know async options are configured even if loader is missing\n      field.asyncOptions = asyncOptionsConfig\n    }\n  }\n\n  addFields(field, schema, originalSchema, strictInputType, asyncLoaders, formValues)\n\n  return field\n}\n","import type { Field } from '../field/type'\nimport type { JsfSchema } from '../types'\n\nfunction sort(fields: Field[], order: string[]): Field[] {\n  // Map from field name to expected index\n  const indexMap: Record<string, number | undefined> = {}\n  order.forEach((key, index) => {\n    indexMap[key] = index\n  })\n\n  const nextFields = fields.sort((a, b) => {\n    // Compare by index\n    const indexA = indexMap[a.name] ?? Infinity\n    const indexB = indexMap[b.name] ?? Infinity\n\n    // The else actually only happens when both are Infinity,\n    // i.e., not specified in the order array\n    if (indexA !== indexB) {\n      return indexA - indexB\n    }\n\n    // If not specified, maintain original relative order\n    return fields.indexOf(a) - fields.indexOf(b)\n  })\n\n  return nextFields\n}\n\n/**\n * Sort fields by schema's `x-jsf-order`\n */\nexport function setCustomOrder(schema: JsfSchema, fields: Field[]): Field[] {\n  // TypeScript does not yield if we remove this check,\n  // but it's only because our typing is likely not right.\n  // See internal discussion:\n  // - https://remote-com.slack.com/archives/C02HTN0LY02/p1738745237733389?thread_ts=1738741631.346809&cid=C02HTN0LY02\n  if (typeof schema === 'boolean') {\n    throw new TypeError('Schema must be an object')\n  }\n\n  if (schema['x-jsf-order'] !== undefined) {\n    return sort(fields, schema['x-jsf-order'])\n  }\n\n  return fields\n}\n","import type { ObjectValue, SchemaValue } from '../types'\n\n/**\n * Type guard to check if a given SchemaValue is an ObjectValue\n * @param v - The value to check\n * @returns `true` if the value is an object, `false` otherwise\n */\nexport function isObjectValue(v: SchemaValue): v is ObjectValue {\n  return typeof v === 'object' && v !== null && !Array.isArray(v)\n}\n\n/**\n * Compare two values for deep equality\n * @param a - The first value to compare\n * @param b - The second value to compare\n * @returns `true` if the values are equal, `false` otherwise\n * @description This function is compares two values for deep equality.\n * Primitives are compared using strict equality.\n * Arrays are compared element by element using recursion.\n * Objects are compared key by key using recursion.\n */\nexport function deepEqual(a: SchemaValue, b: SchemaValue): boolean {\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a === b) {\n    return true\n  }\n\n  // If both are null, the check above has returned true.\n  // If one is null, we return false because we know they are not equal\n  // and since `typeof null === 'object'`, we must not let the null value\n  // pass through as an object.\n  if (a === null || b === null) {\n    return false\n  }\n\n  // Handle arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    // If the array lengths are different, the arrays are not equal\n    if (a.length !== b.length) {\n      return false\n    }\n\n    // If all values are equal, the arrays are equal\n    return a.every((item, index) => deepEqual(item, b[index]))\n  }\n\n  // Handle objects\n  if (isObjectValue(a) && isObjectValue(b)) {\n    const aKeys = Object.keys(a).sort()\n    const bKeys = Object.keys(b).sort()\n\n    // If the key lengths are different, the objects are not equal\n    if (aKeys.length !== bKeys.length) {\n      return false\n    }\n\n    // If the keys are different, the objects are not equal\n    if (!deepEqual(aKeys, bKeys)) {\n      return false\n    }\n\n    // Check all values\n    return aKeys.every(key => deepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * Deep clones an object using structuredClone if available, otherwise falls back to JSON.parse/stringify approach.\n * Please note: some properties might not be serializable (e.g. functions), so they will be lost in the clone.\n *\n * @param obj - The object to clone\n * @returns deep clone of the original object\n * @throws If the object contains circular references and structuredClone is not available\n */\nexport function safeDeepClone<T>(obj: T): T {\n  // Check if structuredClone is available\n  if (typeof structuredClone === 'function') {\n    try {\n      return structuredClone(obj)\n    }\n    catch (err) {\n      console.warn('structuredClone failed, falling back to JSON method:', err)\n      // Fall through to JSON method\n    }\n  }\n\n  // Fallback to JSON.parse/stringify approach\n  try {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  catch {\n    throw new Error('Deep clone failed: Object may contain circular references or non-serializable values')\n  }\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { JsfSchema, JsonLogicContext, NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { type LegacyOptions, validateSchema } from './schema'\nimport { deepEqual } from './util'\n\n/**\n * Validate an array against a schema\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param options - The validation options\n * @param jsonLogicContext - The JSON logic context\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * Validates the array against the schema while keeping track of the path to the array.\n * Each item in the array is validated with `validateSchema`.\n */\nexport function validateArray(\n  value: SchemaValue,\n  schema: JsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath,\n): ValidationError[] {\n  if (!Array.isArray(value)) {\n    return []\n  }\n\n  return [\n    ...validateLength(schema, value, path),\n    ...validateUniqueItems(schema, value, path),\n    ...validateContains(value, schema, options, jsonLogicContext, path),\n    ...validatePrefixItems(schema, value, options, jsonLogicContext, path),\n    ...validateItems(schema, value, options, jsonLogicContext, path),\n  ]\n}\n\n/**\n * Validate the length constraint of an array\n * @param schema - The schema to validate against\n * @param value - The array value to validate\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * Validates the length constraint of an array.\n * If the `maxItems` keyword is defined, the array must contain at most `maxItems` items.\n * If the `minItems` keyword is defined, the array must contain at least `minItems` items.\n */\nfunction validateLength(\n  schema: NonBooleanJsfSchema,\n  value: SchemaValue[],\n  path: ValidationErrorPath,\n): ValidationError[] {\n  const errors: ValidationError[] = []\n\n  const itemsLength = value.length\n\n  if (schema.maxItems !== undefined && itemsLength > schema.maxItems) {\n    errors.push({ path, validation: 'maxItems', schema, value })\n  }\n\n  if (schema.minItems !== undefined && itemsLength < schema.minItems) {\n    errors.push({ path, validation: 'minItems', schema, value })\n  }\n\n  return errors\n}\n\n/**\n * Validate the items constraint of an array\n * @param schema - The schema to validate against\n * @param values - The array value to validate\n * @param options - The validation options\n * @param jsonLogicContext - The JSON logic context\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * Validates the items constraint of an array.\n * If the `items` keyword is defined, each item in the array must match the schema of the `items` keyword.\n * When the `prefixItems` keyword is defined, the items constraint is validated only for the items after the prefix items.\n */\nfunction validateItems(\n  schema: NonBooleanJsfSchema,\n  values: SchemaValue[],\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath,\n): ValidationError[] {\n  if (schema.items === undefined) {\n    return []\n  }\n\n  const errors: ValidationError[] = []\n  const startIndex = Array.isArray(schema.prefixItems) ? schema.prefixItems.length : 0\n\n  for (const [i, item] of values.slice(startIndex).entries()) {\n    errors.push(\n      ...validateSchema(\n        item,\n        schema.items,\n        options,\n        [...path, 'items', i + startIndex],\n        jsonLogicContext,\n      ),\n    )\n  }\n\n  return errors\n}\n\n/**\n * Validate the prefixItems constraint of an array\n * @param schema - The schema to validate against\n * @param values - The array value to validate\n * @param options - The validation options\n * @param jsonLogicContext - The JSON logic context\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * Validates the prefixItems constraint of an array.\n * If the `prefixItems` keyword is defined, each item in the array must match the schema of the corresponding prefix item.\n */\nfunction validatePrefixItems(\n  schema: NonBooleanJsfSchema,\n  values: SchemaValue[],\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath,\n): ValidationError[] {\n  if (!Array.isArray(schema.prefixItems)) {\n    return []\n  }\n\n  const errors: ValidationError[] = []\n  for (const [i, item] of values.entries()) {\n    if (i < schema.prefixItems.length) {\n      errors.push(\n        ...validateSchema(\n          item,\n          schema.prefixItems[i] as JsfSchema,\n          options,\n          [...path, 'prefixItems', i],\n          jsonLogicContext,\n        ),\n      )\n    }\n  }\n\n  return errors\n}\n\n/**\n * Validate the contains, minContains, and maxContains constraints of an array\n * @param value - The array value to validate\n * @param schema - The schema to validate against\n * @param options - The validation options\n * @param jsonLogicContext - The JSON logic context\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * - When the `contains` keyword is defined without `minContains` and `maxContains`, the array must contain at least one item that is valid against the `contains` schema.\n * - When the `contains` keyword is defined with `minContains` and `maxContains`, the array must contain a number of items that is between `minContains` and `maxContains` that are valid against the `contains` schema.\n */\nfunction validateContains(\n  value: SchemaValue[],\n  schema: NonBooleanJsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath,\n): ValidationError[] {\n  if (!('contains' in schema)) {\n    return []\n  }\n\n  const errors: ValidationError[] = []\n\n  // How many items in the array are valid against the contains schema?\n  const contains = value.filter(\n    item =>\n      validateSchema(\n        item,\n        schema.contains as JsfSchema,\n        options,\n        [...path, 'contains'],\n        jsonLogicContext,\n      ).length === 0,\n  ).length\n\n  if (schema.minContains === undefined && schema.maxContains === undefined) {\n    if (contains < 1) {\n      errors.push({ path, validation: 'contains', schema, value })\n    }\n  }\n  else {\n    if (schema.minContains !== undefined && contains < schema.minContains) {\n      errors.push({ path, validation: 'minContains', schema, value })\n    }\n\n    if (schema.maxContains !== undefined && contains > schema.maxContains) {\n      errors.push({ path, validation: 'maxContains', schema, value })\n    }\n  }\n\n  return errors\n}\n\n/**\n * Validate the uniqueItems constraint of an array\n * @param schema - The schema to validate against\n * @param values - The array value to validate\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * Validates the uniqueItems constraint of an array when the `uniqueItems` keyword is defined as `true`.\n */\nfunction validateUniqueItems(\n  schema: NonBooleanJsfSchema,\n  values: SchemaValue[],\n  path: ValidationErrorPath,\n): ValidationError[] {\n  if (schema.uniqueItems !== true) {\n    return []\n  }\n\n  const seen = new Map()\n\n  for (let i = 0; i < values.length; i++) {\n    for (const prevItem of seen.values()) {\n      if (deepEqual(values[i], prevItem)) {\n        return [{ path, validation: 'uniqueItems', schema, value: values[i] }]\n      }\n    }\n    seen.set(i, values[i])\n  }\n\n  return []\n}\n","/**\n * This module implements JSON Schema composition keywords (allOf, anyOf, oneOf, not).\n * These keywords apply subschemas to the same location in the instance as the parent schema.\n * Each subschema is evaluated independently, and results are combined according to the keyword's logic.\n * @see {@link https://json-schema.org/understanding-json-schema/reference/combining.html Schema Composition}\n */\n\nimport type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { LegacyOptions } from '../form'\nimport type { JsfSchema, JsonLogicContext, SchemaValue } from '../types'\nimport { validateSchema } from './schema'\n\n/**\n * Validate a value against the `allOf` keyword in a schema.\n * The value must validate successfully against ALL schemas in the allOf array.\n * Validation stops at the first schema that fails, returning its errors.\n *\n * @example\n * ```json\n * {\n *   \"allOf\": [\n *     { \"type\": \"string\" },\n *     { \"maxLength\": 5 }\n *   ]\n * }\n * ```\n * This schema validates strings with maximum length of 5.\n */\nexport function validateAllOf(\n  value: SchemaValue,\n  schema: JsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  if (!schema.allOf) {\n    return []\n  }\n\n  for (let i = 0; i < schema.allOf.length; i++) {\n    const subSchema = schema.allOf[i]\n    const errors = validateSchema(value, subSchema, options, [...path, 'allOf', i], jsonLogicContext)\n    if (errors.length > 0) {\n      return errors\n    }\n  }\n\n  return []\n}\n\n/**\n * Validate a value against the `anyOf` keyword in a schema.\n * The value must validate successfully against AT LEAST ONE schema in the anyOf array.\n * Returns no errors if any schema validates, otherwise returns a generic anyOf error.\n *\n * @example\n * ```json\n * {\n *   \"anyOf\": [\n *     { \"type\": \"string\", \"maxLength\": 5 },\n *     { \"type\": \"number\", \"minimum\": 0 }\n *   ]\n * }\n * ```\n * This schema validates either short strings or positive numbers.\n */\nexport function validateAnyOf(\n  value: SchemaValue,\n  schema: JsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  if (!schema.anyOf) {\n    return []\n  }\n\n  // If the path is not empty, we are validating a nested schema (property).\n  // In this case, we need to check if any of the sub-schemas are valid. If not, we indicate\n  // the field is invalid with a generic (anyOf) error.\n  if (path.length !== 0) {\n    for (const subSchema of schema.anyOf) {\n      const errors = validateSchema(value, subSchema, options, path, jsonLogicContext)\n      if (errors.length === 0) {\n        return []\n      }\n    }\n\n    return [\n      {\n        path,\n        validation: 'anyOf',\n        schema,\n        value,\n      },\n    ]\n  }\n\n  const errorGroups: ValidationError[][] = []\n\n  // If the path is empty, we are validating the root schema.\n  // If the number of failed rules is less than the number of rules, it means that the\n  // \"any of\" condition is met, so we return an empty array. Otherwise, we return the flattened errors.\n  for (const subSchema of schema.anyOf) {\n    const schemaErrors = validateSchema(value, subSchema, options, path, jsonLogicContext)\n    // If the schema is not valid, add the errors to the errorGroups array\n    if (schemaErrors.length !== 0) {\n      errorGroups.push(schemaErrors)\n    }\n  }\n\n  const anyConditionMet = errorGroups.length < schema.anyOf.length\n  if (anyConditionMet) {\n    return []\n  }\n  else {\n    // Reversing the errors to show the first error that occurred (in the addErrorMessages function,\n    // the last error is usually the one being displayed)\n    return errorGroups.flat().reverse()\n  }\n}\n\n/**\n * Validate a value against the `oneOf` keyword in a schema.\n * The value must validate successfully against EXACTLY ONE schema in the oneOf array.\n * Returns an error if no schemas validate or if multiple schemas validate.\n * No error is returned if the oneOf array is empty.\n *\n * @example\n * ```json\n * {\n *   \"oneOf\": [\n *     { \"type\": \"number\", \"multipleOf\": 5 },\n *     { \"type\": \"number\", \"multipleOf\": 3 }\n *   ]\n * }\n * ```\n * This schema validates numbers that are multiples of either 5 or 3, but not both.\n */\nexport function validateOneOf(\n  value: SchemaValue,\n  schema: JsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  if (!schema.oneOf) {\n    return []\n  }\n\n  if (schema.oneOf.length === 0) {\n    return []\n  }\n\n  let validCount = 0\n\n  for (let i = 0; i < schema.oneOf.length; i++) {\n    const errors = validateSchema(value, schema.oneOf[i], options, path, jsonLogicContext)\n    if (errors.length === 0) {\n      validCount++\n      if (validCount > 1) {\n        break\n      }\n    }\n  }\n\n  if (validCount === 0) {\n    return [\n      {\n        path,\n        validation: 'oneOf',\n        schema,\n        value,\n      },\n    ]\n  }\n\n  if (validCount > 1) {\n    return [\n      {\n        path,\n        validation: 'oneOf',\n        schema,\n        value,\n      },\n    ]\n  }\n\n  return []\n}\n\n/**\n * Validate a value against the `not` keyword in a schema.\n * The value must NOT validate successfully against the schema defined by the not keyword.\n * Returns an error if the value validates against the not schema.\n *\n * @example\n * ```json\n * {\n *   \"not\": { \"type\": \"string\" }\n * }\n * ```\n * This schema validates any value that is not a string.\n *\n * Note: When the not schema is a boolean:\n * - true: Always returns an error (nothing should validate)\n * - false: Always returns no errors (everything validates)\n */\nexport function validateNot(\n  value: SchemaValue,\n  schema: JsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  if (schema.not === undefined) {\n    return []\n  }\n\n  if (typeof schema.not === 'boolean') {\n    return schema.not ? [{ path, validation: 'not', schema, value }] : []\n  }\n\n  const notErrors = validateSchema(value, schema.not, options, path, jsonLogicContext)\n  return notErrors.length === 0 ? [{ path, validation: 'not', schema, value }] : []\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { deepEqual } from './util'\n\n/**\n * Validate that a value is equal to a constant\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param path - The path to the value\n * @returns An array of validation errors\n * @description This function validates that a value is equal to a constant.\n * The constant is defined in the `const` property of the schema.\n * The value is validated against the constant using deep equality.\n * @see https://json-schema.org/understanding-json-schema/reference/const\n * @see https://json-schema.org/draft/2020-12/json-schema-validation#name-enum\n */\nexport function validateConst(\n  value: SchemaValue,\n  schema: NonBooleanJsfSchema,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  const constValue = typeof schema.const !== 'undefined' ? schema.const : schema.value\n\n  if (constValue === undefined) {\n    return []\n  }\n\n  if (!deepEqual(constValue, value)) {\n    return [\n      { path, validation: 'const', schema, value },\n    ]\n  }\n\n  return []\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { deepEqual } from './util'\n\n/**\n * Validate that the value is one of the allowed enum values\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param path - The path to the value\n * @returns An array of validation errors\n *\n * @example\n * ```ts\n * validateEnum('foo', { enum: ['foo', 'bar'] }) // []\n * validateEnum('baz', { enum: ['foo', 'bar'] }) // [{ path: [], validation: 'enum', message: 'The option \"baz\" is not valid.' }]\n * ```\n * @see https://json-schema.org/understanding-json-schema/reference/enum\n * @see https://json-schema.org/draft/2020-12/json-schema-validation#name-enum\n */\nexport function validateEnum(\n  value: SchemaValue,\n  schema: NonBooleanJsfSchema,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  if (schema.enum === undefined) {\n    return []\n  }\n\n  if (!schema.enum.some(enumValue => deepEqual(enumValue, value))) {\n    return [\n      { path, validation: 'enum', schema, value },\n    ]\n  }\n\n  return []\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { isObjectValue } from './util'\n\n// Represents a file-like object, either a browser native File or a plain object.\n// Both must have name (string) and size (number) properties.\nexport type FileLike = (File & { name: string, size: number }) | { name: string, size: number }\n\n/**\n * Validates file-specific constraints (maxFileSize, accept).\n *\n * The value is expected to be `null`, `undefined`, or an array of `FileLike` objects.\n * Each `FileLike` object must have `name` (string) and `size` (number) properties.\n *\n * @param value - The value to validate.\n * @param schema - The schema object, potentially containing 'x-jsf-presentation' with\n *                 'maxFileSize' (in KB) and/or 'accept' (comma-separated string).\n * @param path - The path to the current field in the validation context.\n * @returns An array of validation errors, empty if validation passes.\n */\nexport function validateFile(\n  value: SchemaValue,\n  schema: NonBooleanJsfSchema,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  // Early exit conditions\n  // 1. Check if schema indicates a potential file input\n  const presentation = schema['x-jsf-presentation']\n  const isExplicitFileInput = presentation?.inputType === 'file'\n  const hasFileKeywords\n    = typeof presentation?.maxFileSize === 'number' || typeof presentation?.accept === 'string'\n  const isPotentialFileInput = isExplicitFileInput || hasFileKeywords\n\n  if (!isPotentialFileInput) {\n    return [] // Not a file input schema, nothing to validate here.\n  }\n\n  // 2. Check if the value is an array. Non-arrays (like null, object, string) are handled by validateType.\n  if (!Array.isArray(value)) {\n    return [] // File validation only applies to arrays.\n  }\n\n  // Actual file validation logic\n  // If value is an empty array, no further file validation needed.\n  if (value.length === 0) {\n    return []\n  }\n\n  // 2. Check structure of array items: Each item must be a FileLike object.\n  const isStructureValid = value.every(\n    file => isObjectValue(file) && typeof file.name === 'string' && typeof file.size === 'number',\n  )\n\n  if (!isStructureValid) {\n    return [{ path, validation: 'fileStructure', schema, value }]\n  }\n\n  // Now we know value is a valid FileLike[] with at least one item.\n  const files = value as FileLike[]\n\n  // 3. Validate maxFileSize (presentation.maxFileSize is expected in KB)\n  if (typeof presentation?.maxFileSize === 'number') {\n    const maxSizeInBytes = presentation.maxFileSize * 1024 // Convert KB from schema to Bytes\n    // Check if *any* file exceeds the limit.\n    const isAnyFileTooLarge = files.some(file => file.size > maxSizeInBytes)\n\n    if (isAnyFileTooLarge) {\n      return [{ path, validation: 'maxFileSize', schema, value }]\n    }\n  }\n\n  // 4. Validate accepted file formats (presentation.accept is comma-separated string)\n  if (typeof presentation?.accept === 'string' && presentation.accept.trim() !== '') {\n    const acceptedFormats = presentation.accept\n      .toLowerCase()\n      .split(',')\n      .map((f: string) => f.trim())\n      .filter((f: string) => f)\n      // Normalize formats (handle leading dots)\n      .map((f: string) => (f.startsWith('.') ? f : `.${f}`))\n\n    if (acceptedFormats.length > 0) {\n      // Check if *at least one* file has an accepted format.\n      const isAnyFileFormatAccepted = files.some((file) => {\n        const nameLower = file.name.toLowerCase()\n        const extension = nameLower.includes('.') ? `.${nameLower.split('.').pop()}` : ''\n        return extension !== '' && acceptedFormats.includes(extension)\n      })\n\n      // Fail only if *none* of the files have an accepted format.\n      if (!isAnyFileFormatAccepted) {\n        return [{ path, validation: 'accept', schema, value }]\n      }\n    }\n  }\n\n  // If all checks passed\n  return []\n}\n","import type { RulesLogic } from 'json-logic-js'\nimport type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { JsfObjectSchema, JsfSchema, JsonLogicContext, JsonLogicRules, JsonLogicSchema, NonBooleanJsfSchema, ObjectValue, SchemaValue } from '../types'\nimport jsonLogic from 'json-logic-js'\n\n/**\n * Builds a json-logic context based on a schema and the current value\n * @param schema - The schema to build the context from\n * @param value - The current value of the form\n * @returns The json-logic context\n */\nexport function getJsonLogicContextFromSchema(schema: JsonLogicSchema, value: SchemaValue): JsonLogicContext {\n  const { validations, computedValues } = schema\n  const jsonLogicRules: JsonLogicRules = {\n    validations,\n    computedValues,\n  }\n  const jsonLogicContext = {\n    schema: jsonLogicRules,\n    value,\n  }\n  return jsonLogicContext\n}\n\n/**\n * Checks if a string contains handlebars syntax ({{...}})\n * @param value The string to check\n * @returns true if the string contains handlebars syntax, false otherwise\n */\nfunction containsHandlebars(value: string): boolean {\n  return /\\{\\{.*?\\}\\}/.test(value)\n}\n\n/**\n * jsonLogic interprets  undefined and null values differently when running comparisons and that creates inconsistent results.\n * This function attempts to fix that (ported from v0).\n *\n * @param {object} values - a set of values from a form\n * @returns {object} values object without any undefined\n */\nfunction replaceUndefinedAndNullValuesWithNaN(values: ObjectValue = {}) {\n  return Object.entries(values).reduce((prev, [key, value]) => {\n    return { ...prev, [key]: value === undefined || value === null ? Number.NaN : value }\n  }, {})\n}\n\n/**\n * Validates the JSON Logic rules for a given schema.\n *\n * @param {NonBooleanJsfSchema} schema - JSON Schema to validate.\n * @param {JsonLogicContext | undefined} jsonLogicContext - JSON Logic context.\n * @param {ValidationErrorPath} path - Current validation error path.\n * @throws {Error} If a validation has missing rule.\n */\nexport function validateJsonLogicRules(\n  schema: NonBooleanJsfSchema,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  const validations = schema['x-jsf-logic-validations']\n\n  // if the current schema has no validations, we skip the validation\n  if (!validations || validations.length === 0) {\n    return []\n  }\n\n  return validations.map((validationName: string) => {\n    const validationData = jsonLogicContext?.schema?.validations?.[validationName]\n    const formValue = jsonLogicContext?.value\n\n    // if the validation name does not reference any valid rule, we throw an error\n    if (!validationData) {\n      throw new Error(\n        `[json-schema-form] json-logic error: \"${schema.title}\" required validation \"${validationName}\" doesn't exist.`,\n      )\n    }\n\n    const result: any = jsonLogic.apply(validationData.rule, replaceUndefinedAndNullValuesWithNaN(formValue as ObjectValue))\n\n    // If the condition is false, we return a validation error\n    if (result === false) {\n      // We default to consider the error message as a string\n      // However, if it contains handlebars, we need to evaluate it using the computed values\n      let errorMessage = validationData.errorMessage\n\n      if (errorMessage && containsHandlebars(errorMessage)) {\n        errorMessage = errorMessage.replace(/\\{\\{(.*?)\\}\\}/g, (_, handlebarsVar) => {\n          const computationName = handlebarsVar.trim()\n          const jsonLogicComputation = jsonLogicContext.schema.computedValues?.[computationName]\n\n          // If the handlebars variable matches the name of a computation, we run it\n          if (jsonLogicComputation) {\n            return jsonLogic.apply(jsonLogicComputation.rule, replaceUndefinedAndNullValuesWithNaN(formValue as ObjectValue))\n          }\n          else {\n            // Otherwise, it's probably referring to a variable in the form, so we use it instead\n            return jsonLogic.apply({ var: computationName }, replaceUndefinedAndNullValuesWithNaN(formValue as ObjectValue))\n          }\n        })\n      }\n\n      return [{ path, validation: 'json-logic', customErrorMessage: errorMessage, schema, value: formValue } as ValidationError]\n    }\n\n    return []\n  }).flat()\n}\n\nexport function computePropertyValues(\n  name: string,\n  rule: RulesLogic,\n  values: SchemaValue,\n): any {\n  if (!rule) {\n    throw new Error(\n      `[json-schema-form] json-logic error: Computed value \"${name}\" doesn't exist`,\n    )\n  }\n\n  const result: any = jsonLogic.apply(rule, replaceUndefinedAndNullValuesWithNaN(values as ObjectValue))\n  return result\n}\n\n/**\n * Applies any computed attributes to a schema, based on the provided values. When there are values to apply,\n * Note: this function mutates the schema in place.\n *\n * @param schema - The schema to apply computed attributes to\n * @param computedValuesDefinition - The computed values to apply\n * @param values - The current form values\n * @returns The schema with computed attributes applied\n */\nexport function applyComputedAttrsToSchema(schema: JsfObjectSchema, computedValuesDefinition: JsonLogicRules['computedValues'], values: SchemaValue): JsfObjectSchema {\n  if (computedValuesDefinition) {\n    const computedValues: Record<string, any> = {}\n\n    Object.entries(computedValuesDefinition).forEach(([name, definition]) => {\n      const computedValue = computePropertyValues(name, definition.rule, values)\n      computedValues[name] = computedValue\n    })\n\n    cycleThroughPropertiesAndApplyValues(schema, computedValues)\n  }\n\n  return schema\n}\n\n/**\n * Cycles through the properties of a schema and applies the computed values to it\n * @param schemaCopy - The schema to apply computed values to\n * @param computedValues - The computed values to apply\n */\nfunction cycleThroughPropertiesAndApplyValues(schemaCopy: JsfSchema, computedValues: Record<string, string>) {\n  function processProperty(propertySchema: JsfSchema) {\n    // Checking that the schema is non-boolean and is has a type property before processing it\n    if (typeof propertySchema !== 'object') {\n      return\n    }\n\n    const computedAttrs = propertySchema['x-jsf-logic-computedAttrs']\n    if (computedAttrs) {\n      cycleThroughAttrsAndApplyValues(propertySchema, computedValues, computedAttrs)\n    }\n\n    // If the schemas has properties, we need to cycle through each one and apply the computed values\n    if (typeof propertySchema.properties === 'object') {\n      for (const propertyName in propertySchema.properties) {\n        processProperty(propertySchema.properties[propertyName])\n      }\n    }\n\n    // If the schema has an if statement, we need to cycle through the properties and apply the computed values\n    if (typeof propertySchema.if === 'object') {\n      cycleThroughPropertiesAndApplyValues(propertySchema.if, computedValues)\n    }\n\n    /* If the schema has an allOf or anyOf property, we need to cycle through each property inside it and\n    * apply the computed values\n    */\n\n    if (propertySchema.allOf && propertySchema.allOf.length > 0) {\n      for (const schema of propertySchema.allOf) {\n        cycleThroughPropertiesAndApplyValues(schema, computedValues)\n      }\n    }\n\n    if (propertySchema.anyOf && propertySchema.anyOf.length > 0) {\n      for (const schema of propertySchema.anyOf) {\n        cycleThroughPropertiesAndApplyValues(schema, computedValues)\n      }\n    }\n\n    if (propertySchema.oneOf && propertySchema.oneOf.length > 0) {\n      for (const schema of propertySchema.oneOf) {\n        cycleThroughPropertiesAndApplyValues(schema, computedValues)\n      }\n    }\n\n    // deleting x-jsf-logic-computedAttrs to keep the schema clean\n    delete propertySchema['x-jsf-logic-computedAttrs']\n  }\n\n  processProperty(schemaCopy)\n}\n\n/**\n * Cycles through the attributes of a schema and applies the computed values to it\n * @param propertySchema - The schema to apply computed values to\n * @param computedValues - The computed values to apply\n */\nfunction cycleThroughAttrsAndApplyValues(propertySchema: JsfSchema, computedValues: Record<string, string>, computedAttrs: JsfSchema['x-jsf-logic-computedAttrs']) {\n  if (typeof propertySchema !== 'object') {\n    return\n  }\n\n  /**\n   * Evaluates a string or a handlebars template, using the computed values mapping, and returns the computed value\n   * @param message - The string or template to evaluate\n   * @returns The computed value\n   */\n  function evalStringOrTemplate(message: string) {\n    // If it's a string, we can apply it directly by referencing the computed value by key\n    if (!containsHandlebars(message)) {\n      return computedValues[message]\n    }\n\n    // If it's a template, we need to interpolate it, replacing the handlebars with the computed value\n    return message.replace(/\\{\\{(.*?)\\}\\}/g, (_, computation) => {\n      const computationName = computation.trim()\n      return computedValues[computationName] || `{{${computationName}}}`\n    })\n  }\n\n  /**\n   * Recursively applies the computed values to a nested schema\n   * @param propertySchema - The schema to apply computed values to\n   * @param attrName - The name of the attribute to apply the computed values to\n   * @param computationName - The name of the computed value to apply\n   * @param computedValues - The computed values to apply\n   */\n  function applyNestedComputedValues(propertySchema: JsfSchema, attrName: string, computationName: string | object, computedValues: Record<string, string>) {\n    // Checking that the schema is non-boolean and is has a type property before processing it\n    if (typeof propertySchema !== 'object') {\n      return\n    }\n\n    const attributeName = attrName as keyof NonBooleanJsfSchema\n    if (!propertySchema[attributeName]) {\n      // Making sure the attribute object is created if it does not exist in the original schema\n      propertySchema[attributeName] = {}\n    }\n\n    Object.entries(computationName).forEach(([key, compName]) => {\n      if (typeof compName === 'string') {\n        propertySchema[attributeName][key] = evalStringOrTemplate(compName)\n      }\n      else {\n        applyNestedComputedValues(propertySchema[attributeName], key, compName, computedValues)\n      }\n    })\n  }\n\n  for (const key in computedAttrs) {\n    const attributeName = key as keyof NonBooleanJsfSchema\n    const computationName = computedAttrs[key]\n    // If the computed value is a string, we can apply it directly by referencing the computed value by key\n    if (typeof computationName === 'string') {\n      propertySchema[attributeName] = evalStringOrTemplate(computationName)\n    }\n    else if (typeof propertySchema === 'object') {\n      // Otherwise, it's a nested object, so we need to apply the computed values to the nested object\n      applyNestedComputedValues(propertySchema, attributeName, computationName, computedValues)\n    }\n  }\n}\n\nexport function addCustomJsonLogicOperations(ops?: Record<string, (...args: any[]) => any>) {\n  if (ops) {\n    for (const [name, func] of Object.entries(ops)) {\n      jsonLogic.add_operation(name, func)\n    }\n  }\n}\n\nexport function removeCustomJsonLogicOperations(ops?: Record<string, (...args: any[]) => any>) {\n  if (ops) {\n    for (const name of Object.keys(ops)) {\n      jsonLogic.rm_operation(name)\n    }\n  }\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { getSchemaType } from './schema'\n\n/**\n * Validate a number against a schema\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * Implements number validation according to JSON Schema 2020-12:\n * - MultipleOf validation\n * - Maximum validation\n * - ExclusiveMaximum validation\n * - Minimum validation\n * - ExclusiveMinimum validation\n */\nexport function validateNumber(\n  value: SchemaValue,\n  schema: NonBooleanJsfSchema,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  const errors: ValidationError[] = []\n  const schemaType = getSchemaType(schema)\n\n  if (typeof value !== 'number') {\n    return []\n  }\n\n  if (schemaType !== undefined && !['number', 'integer'].includes(schemaType as string)) {\n    return []\n  }\n\n  // MultipleOf validation - dividing value by multipleOf must have no remainder\n  if (schema.multipleOf !== undefined && value % schema.multipleOf !== 0) {\n    errors.push({ path, validation: 'multipleOf', schema, value })\n  }\n\n  // Maximum validation - value must be less than or equal to maximum\n  if (schema.maximum !== undefined && value > schema.maximum) {\n    errors.push({ path, validation: 'maximum', schema, value })\n  }\n\n  // ExclusiveMaximum validation - value must be less than exclusiveMaximum\n  if (schema.exclusiveMaximum !== undefined && value >= schema.exclusiveMaximum) {\n    errors.push({ path, validation: 'exclusiveMaximum', schema, value })\n  }\n\n  // Minimum validation - value must be greater than or equal to minimum\n  if (schema.minimum !== undefined && value < schema.minimum) {\n    errors.push({ path, validation: 'minimum', schema, value })\n  }\n\n  // ExclusiveMinimum validation - value must be greater than exclusiveMinimum\n  if (schema.exclusiveMinimum !== undefined && value <= schema.exclusiveMinimum) {\n    errors.push({ path, validation: 'exclusiveMinimum', schema, value })\n  }\n\n  return errors\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { LegacyOptions } from '../form'\nimport type { JsonLogicContext, NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { validateSchema } from './schema'\nimport { isObjectValue } from './util'\n\n/**\n * Validate an object against a schema\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param options - The validation options\n * @param jsonLogicContext - The JSON Logic context\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * Validates each property of object against the schema while keeping track of the path to the property.\n * Each property is validated with `validateSchema`.\n */\nexport function validateObject(\n  value: SchemaValue,\n  schema: NonBooleanJsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  if (typeof schema === 'object' && schema.properties && isObjectValue(value)) {\n    const errors = []\n    for (const [key, propertySchema] of Object.entries(schema.properties)) {\n      errors.push(...validateSchema(value[key], propertySchema, options, [...path, key], jsonLogicContext))\n    }\n    return errors\n  }\n\n  return []\n}\n","// @generated\n// This code is automatically generated. Manual editing is not recommended.\n\n/*\n * BSD-2-Clause License\n *\n * Original source code is copyright (c) 2022 Jeremy Rylan\n * <https://github.com/jrylan>\n *\n * Documentation and keyword descriptions are copyright (c) 2020 IETF Trust\n * <https://www.ietf.org/>, Austin Wright <aaa@bzfx.net>, Henry Andrews\n * <andrews_henry@yahoo.com>, Ben Hutton <ben@jsonschema.dev>, and Greg Dennis\n * <gregsdennis@yahoo.com>. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport const draft = \"2020-12\" as const;\nexport const $schema = \"https://json-schema.org/draft/2020-12/schema\" as const;\n\ntype MaybeReadonlyArray<T> = Array<T> | ReadonlyArray<T>;\ntype ValueOf<T> = T[keyof T];\n\n/**\n * JSON Schema [Draft 2020-12](https://json-schema.org/draft/2020-12/json-schema-validation.html)\n */\nexport type JSONSchema<\n  Value = any,\n  SchemaType = Value extends boolean ? \"boolean\"\n    : Value extends null ? \"null\"\n    : Value extends number ? \"number\" | \"integer\"\n    : Value extends string ? \"string\"\n    : Value extends unknown[] ? \"array\"\n    : Value extends Record<string | number, unknown> ? \"object\"\n    : JSONSchema.TypeValue,\n> = boolean | {\n  /**\n   * Using JSON Pointer fragments requires knowledge of the structure of the\n   * schema. When writing schema documents with the intention to provide\n   * re-usable schemas, it may be preferable to use a plain name fragment\n   * that is not tied to any particular structural location.  This allows a\n   * subschema to be relocated without requiring JSON Pointer references to\n   * be updated.\n   *\n   * The `$anchor` keyword is used to specify such a fragment.  It is an\n   * identifier keyword that can only be used to create plain name fragments.\n   *\n   * If present, the value of this keyword MUST be a string, which MUST start\n   * with a letter `[A-Za-z]`, followed by any number of letters, digits\n   * `[0-9]`, hyphens `-`, underscores `_`, colons `:`,\n   * or periods `.`.\n   *\n   * Note that the anchor string does not include the `#` character,\n   * as it is not a URI-reference.  An `{\"$anchor\": \"foo\"}` becomes the\n   * fragment `#foo` when used in a URI.\n   *\n   * The base URI to which the resulting fragment is appended is determined\n   * by the `$id` keyword as explained in the previous section.\n   * Two `$anchor` keywords in the same schema document MAY have the same\n   * value if they apply to different base URIs, as the resulting full URIs\n   * will be distinct.  However, the effect of two `$anchor` keywords\n   * with the same value and the same base URI is undefined.  Implementations\n   * MAY raise an error if such usage is detected.\n   */\n  $anchor?: string;\n\n  /**\n   * This keyword reserves a location for comments from schema authors to\n   * readers or maintainers of the schema.\n   *\n   * The value of this keyword MUST be a string. Implementations MUST NOT\n   * present this string to end users.  Tools for editing schemas SHOULD\n   * support displaying and editing this keyword.  The value of this keyword\n   * MAY be used in debug or error output which is intended for developers\n   * making use of schemas.\n   *\n   * Schema vocabularies SHOULD allow `$comment` within any object\n   * containing vocabulary keywords.  Implementations MAY assume `$comment`\n   * is allowed unless the vocabulary specifically forbids it.  Vocabularies\n   * MUST NOT specify any effect of `$comment` beyond what is described in\n   * this specification.\n   *\n   * Tools that translate other media types or programming languages\n   * to and from `application/schema+json` MAY choose to convert that media\n   * type or programming language's native comments to or from `$comment`\n   * values. The behavior of such translation when both native comments and\n   * `$comment` properties are present is implementation-dependent.\n   *\n   * Implementations MAY strip `$comment` values at any point during\n   * processing. In particular, this allows for shortening schemas when the\n   * size of deployed schemas is a concern.\n   *\n   * Implementations MUST NOT take any other action based on the presence,\n   * absence, or contents of `$comment` properties.  In particular, the\n   * value of `$comment` MUST NOT be collected as an annotation result.\n   */\n  $comment?: string;\n\n  /**\n   * The `$defs` keyword reserves a location for schema authors to inline\n   * re-usable JSON Schemas into a more general schema. The keyword does not\n   * directly affect the validation result.\n   *\n   * This keyword's value MUST be an object. Each member value of this object\n   * MUST be a valid JSON Schema.\n   */\n  $defs?: Record<string, JSONSchema>;\n\n  /**\n   * \"The `$dynamicAnchor` indicates that the fragment is an extension\n   * point when used with the `$dynamicRef` keyword. This low-level,\n   * advanced feature makes it easier to extend recursive schemas such as the\n   * meta-schemas, without imposing any particular semantics on that\n   * extension. See `$dynamicRef` for more details.\n   */\n  $dynamicAnchor?: string;\n\n  /**\n   * The `$dynamicRef` keyword is an applicator that allows for deferring\n   * the full resolution until runtime, at which point it is resolved each\n   * time it is encountered while evaluating an instance.\n   *\n   * Together with `$dynamicAnchor`, `$dynamicRef` implements a\n   * cooperative extension mechanism that is primarily useful with recursive\n   * schemas (schemas that reference themselves).  Both the extension point\n   * and the runtime-determined extension target are defined with\n   * `$dynamicAnchor`, and only exhibit runtime dynamic behavior when\n   * referenced with `$dynamicRef`.\n   *\n   * The value of the `$dynamicRef` property MUST be a string which is\n   * a URI-Reference.  Resolved against the current URI base, it produces\n   * the URI used as the starting point for runtime resolution.  This initial\n   * resolution is safe to perform on schema load.\n   *\n   * If the initially resolved starting point URI includes a fragment that\n   * was created by the `$dynamicAnchor` keyword, the initial URI MUST be\n   * replaced by the URI (including the fragment) for the outermost schema\n   * resource in the [dynamic scope][scopes] that defines\n   * an identically named fragment with `$dynamicAnchor`.\n   *\n   * Otherwise, its behavior is identical to `$ref`, and no runtime\n   * resolution is needed.\n   *\n   * [scopes]: https://json-schema.org/draft/2020-12/json-schema-core.html#scopes\n   *\n   * @format \"uri-reference\"\n   */\n  $dynamicRef?: string;\n\n  /**\n   * The `$id` keyword identifies a schema resource with its\n   * [canonical][[RFC6596]] URI.\n   *\n   * Note that this URI is an identifier and not necessarily a network\n   * locator. In the case of a network-addressable URL, a schema need not be\n   * downloadable from its canonical URI.\n   *\n   * If present, the value for this keyword MUST be a string, and MUST\n   * represent a valid [URI-reference][RFC3986].  This URI-reference SHOULD\n   * be normalized, and MUST resolve to an [absolute-URI][RFC3986] (without a\n   * fragment).  Therefore, `$id` MUST NOT contain a non-empty fragment,\n   * and SHOULD NOT contain an empty fragment.\n   *\n   * Since an empty fragment in the context of the\n   * `application/schema+json` media type refers to the same resource as\n   * the base URI without a fragment, an implementation MAY normalize a URI\n   * ending with an empty fragment by removing the fragment.  However, schema\n   * authors SHOULD NOT rely on this behavior across implementations.\n   *\n   * This URI also serves as the base URI for relative URI-references in\n   * keywords within the schema resource, in accordance with\n   * [RFC 3986][RFC3986] section 5.1.1 regarding base URIs embedded in\n   * content.\n   *\n   * The presence of `$id` in a subschema indicates that the subschema\n   * constitutes a distinct schema resource within a single schema document.\n   * Furthermore, in accordance with [RFC 3986][RFC3986] section 5.1.2\n   * regarding encapsulating entities, if an `$id` in a subschema is a\n   * relative URI-reference, the base URI for resolving that reference is the\n   * URI of the parent schema resource.\n   *\n   * If no parent schema object explicitly identifies itself as a resource\n   * with `$id`, the base URI is that of the entire document.\n   *\n   * The root schema of a JSON Schema document SHOULD contain an `$id`\n   * keyword with an [absolute-URI][RFC3986] (containing a scheme, but no\n   * fragment).\n   *\n   * [RFC6596]: https://datatracker.ietf.org/doc/html/rfc6596\n   * [RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986\n   *\n   * @format \"uri-reference\"\n   */\n  $id?: string;\n\n  /**\n   * The `$ref` keyword is an applicator that is used to reference a\n   * statically identified schema. Its results are the results of the\n   * referenced schema. Other keywords can appear alongside of `$ref` in\n   * the same schema object.\n   *\n   * The value of the `$ref` property MUST be a string which is a\n   * URI-Reference. Resolved against the current URI base, it produces the\n   * URI of the schema to apply.\n   *\n   * @format \"uri-reference\"\n   */\n  $ref?: string;\n\n  /**\n   * The `$schema` keyword is both used as a JSON Schema dialect identifier\n   * and as the identifier of a resource which is itself a JSON Schema, which\n   * describes the set of valid schemas written for this particular dialect.\n   *\n   * The value of this keyword MUST be a [URI][RFC3986] (containing a scheme)\n   * and this URI MUST be normalized. The current schema MUST be valid\n   * against the meta-schema identified by this URI.\n   *\n   * If this URI identifies a retrievable resource, that resource SHOULD be\n   * of media type `application/schema+json`.\n   *\n   * The `$schema` keyword SHOULD be used in the document root schema\n   * object, and MAY be used in the root schema objects of embedded schema\n   * resources. It MUST NOT appear in non-resource root schema objects.  If\n   * absent from the document root schema, the resulting behavior is\n   * implementation-defined.\n   *\n   * Values for this property are defined elsewhere in this and other\n   * documents, and by other parties.\n   *\n   * [RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986\n   *\n   * @format \"uri\"\n   */\n  $schema?: string;\n\n  /**\n   * The `$vocabulary` keyword is used in meta-schemas to identify the\n   * vocabularies available for use in schemas described by that meta-schema.\n   * It is also used to indicate whether each vocabulary is required or\n   * optional, in the sense that an implementation MUST understand the\n   * required vocabularies in order to successfully process the schema.\n   * Together, this information forms a dialect. Any vocabulary that is\n   * understood by the implementation MUST be processed in a manner\n   * consistent with the semantic definitions contained within the\n   * vocabulary.\n   *\n   * The value of this keyword MUST be an object.  The property names in the\n   * object MUST be URIs (containing a scheme) and this URI MUST be\n   * normalized. Each URI that appears as a property name identifies a\n   * specific set of keywords and their semantics.\n   *\n   * The URI MAY be a URL, but the nature of the retrievable resource is\n   * currently undefined, and reserved for future use.  Vocabulary authors\n   * MAY use the URL of the vocabulary specification, in a human-readable\n   * media type such as `text/html` or `text/plain`, as the vocabulary\n   * URI.\n   *\n   * The values of the object properties MUST be booleans. If the value is\n   * `true`, then implementations that do not recognize the vocabulary MUST\n   * refuse to process any schemas that declare this meta-schema with\n   * `$schema`.  If the value is `false`, implementations that do not\n   * recognize the vocabulary SHOULD proceed with processing such schemas.\n   * The value has no impact if the implementation understands the\n   * vocabulary.\n   *\n   * Unrecognized keywords SHOULD be ignored.  This remains the case for\n   * keywords defined by unrecognized vocabularies.  It is not currently\n   * possible to distinguish between unrecognized keywords that are defined\n   * in vocabularies from those that are not part of any vocabulary.\n   *\n   * The `$vocabulary` keyword SHOULD be used in the root schema of any\n   * schema document intended for use as a meta-schema.  It MUST NOT appear\n   * in subschemas.\n   *\n   * The `$vocabulary` keyword MUST be ignored in schema documents that are\n   * not being processed as a meta-schema.\n   */\n  $vocabulary?: Record<string, string>;\n\n  /**\n   * @deprecated `additionalItems` has been deprecated in favor of `prefixItems`\n   * paired with `items`.\n   */\n  additionalItems?: JSONSchema;\n\n  /**\n   * The value of `additionalProperties` MUST be a valid JSON Schema.\n   *\n   * The behavior of this keyword depends on the presence and annotation\n   * results of `properties` and `patternProperties` within the same\n   * schema object. Validation with `additionalProperties` applies only to\n   * the child values of instance names that do not appear in the annotation\n   * results of either `properties` or `patternProperties`.\n   *\n   * For all such properties, validation succeeds if the child instance\n   * validates against the `additionalProperties` schema.\n   *\n   * The annotation result of this keyword is the set of instance property\n   * names validated by this keyword's subschema. Annotation results for\n   * `additionalProperties` keywords from multiple schemas applied to the\n   * same instance location are combined by taking the union of the sets.\n   *\n   * Omitting this keyword has the same assertion behavior as an empty\n   * schema.\n   *\n   * Implementations MAY choose to implement or optimize this keyword in\n   * another way that produces the same effect, such as by directly checking\n   * the names in `properties` and the patterns in `patternProperties`\n   * against the instance property set.\n   */\n  additionalProperties?: JSONSchema;\n\n  /**\n   * This keyword's value MUST be a non-empty array. Each item of the array\n   * MUST be a valid JSON Schema.\n   *\n   * An instance validates successfully against this keyword if it validates\n   * successfully against all schemas defined by this keyword's value.\n   */\n  allOf?: MaybeReadonlyArray<JSONSchema<Value, SchemaType>>;\n\n  /**\n   * This keyword's value MUST be a non-empty array. Each item of the array\n   * MUST be a valid JSON Schema.\n   *\n   * An instance validates successfully against this keyword if it validates\n   * successfully against at least one schema defined by this keyword's\n   * value.\n   */\n  anyOf?: MaybeReadonlyArray<JSONSchema<Value, SchemaType>>;\n\n  /**\n   * An instance validates successfully against this keyword if its value is\n   * equal to the value of the keyword.\n   *\n   * Use of this keyword is functionally equivalent to the `enum` keyword\n   * with a single value.\n   */\n  const?: Value;\n\n  /**\n   * The value of this keyword MUST be a valid JSON Schema.\n   *\n   * An array instance is valid against `contains` if at least one of its\n   * elements is valid against the given schema. The subschema MUST be\n   * applied to every array element even after the first match has been\n   * found, in order to collect annotations for use by other keywords.\n   * This is to ensure that all possible annotations are collected.\n   *\n   * Logically, the validation result of applying the value subschema to each\n   * item in the array MUST be OR'ed with `false`, resulting in an overall\n   * validation result.\n   *\n   * This keyword produces an annotation value which is an array of the\n   * indexes to which this keyword validates successfully when applying its\n   * subschema, in ascending order. The value MAY be a boolean `true` if\n   * the subschema validates successfully when applied to every index of the\n   * instance. The annotation MUST be present if the instance array to which\n   * this keyword's schema applies is empty.\n   */\n  contains?: JSONSchema<Value, SchemaType>;\n\n  /**\n   * If the instance value is a string, this property defines that the\n   * string SHOULD be interpreted as binary data and decoded using the\n   * encoding named by this property. [RFC 2045, Sec 6.1][RFC2045] lists the\n   * possible values for this property.\n   *\n   * The value of this property SHOULD be ignored if the instance described\n   * is not a string.\n   *\n   * If this keyword is absent, but `contentMediaType` is present, this\n   * indicates that the media type could be encoded into `UTF-8` like any\n   * other JSON string value, and does not require additional decoding.\n   *\n   * The value of this property MUST be a string.\n   *\n   * [RFC2045]: https://datatracker.ietf.org/doc/html/rfc2045#section-6.1\n   */\n  contentEncoding?:\n    | \"7bit\"\n    | \"8bit\"\n    | \"base64\"\n    | \"binary\"\n    | \"ietf-token\"\n    | \"quoted-printable\"\n    | \"x-token\";\n\n  /**\n   * If the instance is a string, this property indicates the media type\n   * of the contents of the string.  If `contentEncoding` is present,\n   * this property describes the decoded string.\n   *\n   * The value of this property must be a media type, as defined by\n   * [RFC 2046][RFC2046]. This property defines the media type of instances\n   * which this schema defines.\n   *\n   * The value of this property SHOULD be ignored if the instance described\n   * is not a string.\n   *\n   * If the `contentEncoding` property is not present, but the instance\n   * value is a string, then the value of this property SHOULD specify a text\n   * document type, and the character set SHOULD be the character set into\n   * which the JSON string value was decoded (for which the default is\n   * Unicode).\n   *\n   * [RFC2046]: https://datatracker.ietf.org/doc/html/rfc2046\n   */\n  contentMediaType?: string;\n\n  /**\n   * If the instance is a string, and if `contentMediaType` is present,\n   * this property contains a schema which describes the structure of the\n   * string.\n   *\n   * This keyword MAY be used with any media type that can be mapped into\n   * JSON Schema's data model.\n   *\n   * The value of this property MUST be a valid JSON schema. It SHOULD be\n   * ignored if `contentMediaType` is not present.\n   */\n  contentSchema?: JSONSchema<Value, SchemaType>;\n\n  /**\n   * This keyword can be used to supply a default JSON value associated with\n   * a particular schema. It is RECOMMENDED that a `default` value be valid\n   * against the associated schema.\n   */\n  default?: Value;\n\n  /**\n   * @deprecated `definitions` has been renamed to `$defs`.\n   */\n  definitions?: Record<string, JSONSchema>;\n\n  /**\n   * @deprecated `dependencies` has been split into two keywords:\n   * `dependentSchemas` and `dependentRequired`.\n   */\n  dependencies?: Record<string, MaybeReadonlyArray<string> | JSONSchema>;\n\n  /**\n   * The value of this keyword MUST be an object.  Properties in\n   * this object, if any, MUST be arrays.  Elements in each array,\n   * if any, MUST be strings, and MUST be unique.\n   *\n   * This keyword specifies properties that are required if a specific\n   * other property is present.  Their requirement is dependent on the\n   * presence of the other property.\n   *\n   * Validation succeeds if, for each name that appears in both\n   * the instance and as a name within this keyword's value, every\n   * item in the corresponding array is also the name of a property\n   * in the instance.\n   *\n   * Omitting this keyword has the same behavior as an empty object.\n   */\n  dependentRequired?: Record<string, MaybeReadonlyArray<string>>;\n\n  /**\n   * This keyword specifies subschemas that are evaluated if the instance is\n   * an object and contains a certain property.\n   *\n   * This keyword's value MUST be an object. Each value in the object MUST be\n   * a valid JSON Schema.\n   *\n   * If the object key is a property in the instance, the entire instance\n   * must validate against the subschema. Its use is dependent on the\n   * presence of the property.\n   *\n   * Omitting this keyword has the same behavior as an empty object.\n   */\n  dependentSchemas?: Record<string, JSONSchema>;\n\n  /**\n   * The value of this keyword MUST be a boolean.  When multiple occurrences\n   * of this keyword are applicable to a single sub-instance, applications\n   * SHOULD consider the instance location to be deprecated if any occurrence\n   * specifies a `true` value.\n   *\n   * If `deprecated` has a value of boolean `true`, it indicates that\n   * applications SHOULD refrain from usage of the declared property. It MAY\n   * mean the property is going to be removed in the future.\n   *\n   * A root schema containing `deprecated` with a value of `true`\n   * indicates that the entire resource being described MAY be removed in the\n   * future.\n   *\n   * The `deprecated` keyword applies to each instance location to which\n   * the schema object containing the keyword successfully applies.  This can\n   * result in scenarios where every array item or object property is\n   * deprecated even though the containing array or object is not.\n   *\n   * Omitting this keyword has the same behavior as a value of `false`.\n   */\n  deprecated?: boolean;\n\n  /**\n   * Can be used to decorate a user interface with explanation or information\n   * about the data produced.\n   */\n  description?: string;\n\n  /**\n   * This keyword's value MUST be a valid JSON Schema.\n   *\n   * When `if` is present, and the instance fails to validate against its\n   * subschema, then validation succeeds against this keyword if the instance\n   * successfully validates against this keyword's subschema.\n   *\n   * This keyword has no effect when `if` is absent, or when the instance\n   * successfully validates against its subschema. Implementations MUST NOT\n   * evaluate the instance against this keyword, for either validation or\n   * annotation collection purposes, in such cases.\n   */\n  else?: JSONSchema<Value, SchemaType>;\n\n  /**\n   * The value of this keyword MUST be an array. This array SHOULD have at\n   * least one element. Elements in the array SHOULD be unique.\n   *\n   * An instance validates successfully against this keyword if its value is\n   * equal to one of the elements in this keyword's array value.\n   *\n   * Elements in the array might be of any type, including `null`.\n   */\n  enum?: MaybeReadonlyArray<Value>;\n\n  /**\n   * The value of this keyword MUST be an array. When multiple occurrences of\n   * this keyword are applicable to a single sub-instance, implementations\n   * MUST provide a flat array of all values rather than an array of arrays.\n   *\n   * This keyword can be used to provide sample JSON values associated with a\n   * particular schema, for the purpose of illustrating usage. It is\n   * RECOMMENDED that these values be valid against the associated schema.\n   *\n   * Implementations MAY use the value(s) of `default`, if present, as an\n   * additional example. If `examples` is absent, `default` MAY still be\n   * used in this manner.\n   */\n  examples?: MaybeReadonlyArray<Value>;\n\n  /**\n   * The value of `exclusiveMaximum` MUST be a number, representing an\n   * exclusive upper limit for a numeric instance.\n   *\n   * If the instance is a number, then the instance is valid only if it has a\n   * value strictly less than (not equal to) `exclusiveMaximum`.\n   */\n  exclusiveMaximum?: number;\n\n  /**\n   * The value of `exclusiveMinimum` MUST be a number, representing an\n   * exclusive lower limit for a numeric instance.\n   *\n   * If the instance is a number, then the instance is valid only if it has a\n   * value strictly greater than (not equal to) `exclusiveMinimum`.\n   */\n  exclusiveMinimum?: number;\n\n  /**\n   * Implementations MAY treat `format` as an assertion in addition to an\n   * annotation, and attempt to validate the value's conformance to the\n   * specified semantics.\n   *\n   * The value of this keyword is called a format attribute. It MUST be a\n   * string. A format attribute can generally only validate a given set\n   * of instance types. If the type of the instance to validate is not in\n   * this set, validation for this format attribute and instance SHOULD\n   * succeed. Format attributes are most often applied to strings, but can\n   * be specified to apply to any type.\n   *\n   * Implementations MAY support custom format attributes. Save for agreement\n   * between parties, schema authors SHALL NOT expect a peer implementation\n   * to support such custom format attributes.  An implementation MUST NOT\n   * fail validation or cease processing due to an unknown format attribute.\n   * When treating `format` as an annotation, implementations SHOULD\n   * collect both known and unknown format attribute values.\n   */\n  format?: string;\n\n  /**\n   * This keyword's value MUST be a valid JSON Schema.\n   *\n   * This validation outcome of this keyword's subschema has no direct effect\n   * on the overall validation result. Rather, it controls which of the\n   * `then` or `else` keywords are evaluated.\n   *\n   * Instances that successfully validate against this keyword's subschema\n   * MUST also be valid against the subschema value of the `then` keyword,\n   * if present.\n   *\n   * Instances that fail to validate against this keyword's subschema MUST\n   * also be valid against the subschema value of the `else` keyword, if\n   * present.\n   *\n   * If annotations are being collected, they are collected\n   * from this keyword's subschema in the usual way, including when the\n   * keyword is present without either `then` or `else`.\n   */\n  if?: JSONSchema<Value, SchemaType>;\n\n  /**\n   * The value of `items` MUST be a valid JSON Schema.\n   *\n   * This keyword applies its subschema to all instance elements at indexes\n   * greater than the length of the `prefixItems` array in the same schema\n   * object, as reported by the annotation result of that `prefixItems`\n   * keyword.  If no such annotation result exists, `items` applies its\n   * subschema to all instance array elements.\n   *\n   * Note that the behavior of `items` without `prefixItems` is identical\n   * to that of the schema form of `items` in prior drafts.\n   *\n   * When `prefixItems` is present, the behavior of `items` is identical\n   * to the former `additionalItems` keyword.\n   *\n   * If the `items` subschema is applied to any positions within the\n   * instance array, it produces an annotation result of boolean `true`,\n   * indicating that all remaining array elements have been evaluated against\n   * this keyword's subschema.\n   *\n   * Omitting this keyword has the same assertion behavior as an empty\n   * schema.\n   *\n   * Implementations MAY choose to implement or optimize this keyword\n   * in another way that produces the same effect, such as by directly\n   * checking for the presence and size of a `prefixItems` array.\n   */\n  items?: JSONSchema;\n\n  /**\n   * The value of this keyword MUST be a non-negative integer.\n   *\n   * If `contains` is not present within the same schema object, then this\n   * keyword has no effect.\n   *\n   * An instance array is valid against `maxContains` in two ways,\n   * depending on the form of the annotation result of an adjacent\n   * `contains` keyword. The first way is if the annotation result is an\n   * array and the length of that array is less than or equal to the\n   * `maxContains` value. The second way is if the annotation result is a\n   * boolean `true` and the instance array length is less than or equal to\n   * the `maxContains` value.\n   */\n  maxContains?: number;\n\n  /**\n   * The value of `maximum` MUST be a number, representing an inclusive\n   * upper limit for a numeric instance.\n   *\n   * If the instance is a number, then this keyword validates only if the\n   * instance is less than or exactly equal to `maximum`.\n   */\n  maximum?: number;\n\n  /**\n   * The value of this keyword MUST be a non-negative integer.\n   *\n   * An array instance is valid against `maxItems` if its size is less\n   * than, or equal to, the value of this keyword.\n   *\n   * @minimum 0\n   */\n  maxItems?: number;\n\n  /**\n   * The value of this keyword MUST be a non-negative integer.\n   *\n   * A string instance is valid against this keyword if its length is less\n   * than, or equal to, the value of this keyword.\n   *\n   * The length of a string instance is defined as the number of its\n   * characters as defined by [RFC 8259][RFC8259].\n   *\n   * [RFC8259]: https://datatracker.ietf.org/doc/html/rfc8259\n   *\n   * @minimum 0\n   */\n  maxLength?: number;\n\n  /**\n   * The value of this keyword MUST be a non-negative integer.\n   *\n   * An object instance is valid against `maxProperties` if its number of\n   * `properties` is less than, or equal to, the value of this keyword.\n   *\n   * @minimum 0\n   */\n  maxProperties?: number;\n\n  /**\n   * The value of this keyword MUST be a non-negative integer.\n   *\n   * If `contains` is not present within the same schema object, then this\n   * keyword has no effect.\n   *\n   * An instance array is valid against `minContains` in two ways,\n   * depending on the form of the annotation result of an adjacent\n   * `contains` keyword. The first way is if the annotation result is an\n   * array and the length of that array is greater than or equal to the\n   * `minContains` value. The second way is if the annotation result is a\n   * boolean `true` and the instance array length is greater than or equal\n   * to the `minContains` value.\n   *\n   * A value of `0` is allowed, but is only useful for setting a range\n   * of occurrences from `0` to the value of `maxContains`.  A value of\n   * `0` with no `maxContains` causes `contains` to always pass\n   * validation.\n   *\n   * Omitting this keyword has the same behavior as a value of `1`.\n   *\n   * @default 1\n   */\n  minContains?: number;\n\n  /**\n   * The value of `minimum` MUST be a number, representing an inclusive\n   * lower limit for a numeric instance.\n   *\n   * If the instance is a number, then this keyword validates only if the\n   * instance is greater than or exactly equal to `minimum`.\n   */\n  minimum?: number;\n\n  /**\n   * The value of this keyword MUST be a non-negative integer.\n   *\n   * An array instance is valid against `minItems` if its size is greater\n   * than, or equal to, the value of this keyword.\n   *\n   * Omitting this keyword has the same behavior as a value of `0`.\n   *\n   * @default 0\n   * @minimum 0\n   */\n  minItems?: number;\n\n  /**\n   * The value of this keyword MUST be a non-negative integer.\n   *\n   * A string instance is valid against this keyword if its length is greater\n   * than, or equal to, the value of this keyword.\n   *\n   * The length of a string instance is defined as the number of its\n   * characters as defined by [RFC 8259][RFC8259].\n   *\n   * Omitting this keyword has the same behavior as a value of `0`.\n   *\n   * [RFC8259]: https://datatracker.ietf.org/doc/html/rfc8259\n   *\n   * @default 0\n   * @minimum 0\n   */\n  minLength?: number;\n\n  /**\n   * The value of this keyword MUST be a non-negative integer.\n   *\n   * An object instance is valid against `minProperties` if its number of\n   * `properties` is greater than, or equal to, the value of this keyword.\n   *\n   * Omitting this keyword has the same behavior as a value of `0`.\n   *\n   * @default 0\n   * @minimum 0\n   */\n  minProperties?: number;\n\n  /**\n   * The value of `multipleOf` MUST be a number, strictly greater than\n   * `0`.\n   *\n   * A numeric instance is valid only if division by this keyword's value\n   * results in an integer.\n   *\n   * @exclusiveMinimum 0\n   */\n  multipleOf?: number;\n\n  /**\n   * This keyword's value MUST be a valid JSON Schema.\n   *\n   * An instance is valid against this keyword if it fails to validate\n   * successfully against the schema defined by this keyword.\n   */\n  not?: JSONSchema<Value, SchemaType>;\n\n  /**\n   * This keyword's value MUST be a non-empty array. Each item of the array\n   * MUST be a valid JSON Schema.\n   *\n   * An instance validates successfully against this keyword if it validates\n   * successfully against exactly one schema defined by this keyword's value.\n   */\n  oneOf?: MaybeReadonlyArray<JSONSchema<Value, SchemaType>>;\n\n  /**\n   * The value of this keyword MUST be a string. This string SHOULD be a\n   * valid regular expression, according to the [ECMA-262][ecma262] regular\n   * expression dialect.\n   *\n   * A string instance is considered valid if the regular expression matches\n   * the instance successfully. Recall: regular expressions are not\n   * implicitly anchored.\n   *\n   * [ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\n   *\n   * @format \"regex\"\n   */\n  pattern?: string;\n\n  /**\n   * The value of `patternProperties` MUST be an object. Each property name\n   * of this object SHOULD be a valid regular expression, according to the\n   * [ECMA-262][ecma262] regular expression dialect. Each property value of\n   * this object MUST be a valid JSON Schema.\n   *\n   * Validation succeeds if, for each instance name that matches any regular\n   * expressions that appear as a property name in this keyword's value,\n   * the child instance for that name successfully validates against each\n   * schema that corresponds to a matching regular expression.\n   *\n   * The annotation result of this keyword is the set of instance property\n   * names matched by this keyword. Omitting this keyword has the same\n   * assertion behavior as an empty object.\n   *\n   * [ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\n   */\n  patternProperties?: Record<string, JSONSchema>;\n\n  /**\n   * The value of `prefixItems` MUST be a non-empty array of valid JSON\n   * Schemas.\n   *\n   * Validation succeeds if each element of the instance validates against\n   * the schema at the same position, if any.  This keyword does not\n   * constrain the length of the array.  If the array is longer than this\n   * keyword's value, this keyword validates only the prefix of matching\n   * length.\n   *\n   * This keyword produces an annotation value which is the largest index to\n   * which this keyword applied a subschema.  The value MAY be a boolean\n   * `true` if a subschema was applied to every index of the instance, such\n   * as is produced by the `items` keyword.\n   * This annotation affects the behavior of `items` and\n   * `unevaluatedItems`.\n   *\n   * Omitting this keyword has the same assertion behavior as an empty array.\n   */\n  prefixItems?: MaybeReadonlyArray<JSONSchema> | JSONSchema;\n\n  /**\n   * The value of `properties` MUST be an object. Each value of this object\n   * MUST be a valid JSON Schema.\n   *\n   * Validation succeeds if, for each name that appears in both the instance\n   * and as a name within this keyword's value, the child instance for that\n   * name successfully validates against the corresponding schema.\n   *\n   * The annotation result of this keyword is the set of instance property\n   * names matched by this keyword.\n   *\n   * Omitting this keyword has the same assertion behavior as an empty\n   * object.\n   */\n  properties?: Record<string, JSONSchema>;\n\n  /**\n   * The value of `propertyNames` MUST be a valid JSON Schema.\n   *\n   * If the instance is an object, this keyword validates if every property\n   * name in the instance validates against the provided schema.\n   * Note the property name that the schema is testing will always be a\n   * string.\n   *\n   * Omitting this keyword has the same behavior as an empty schema.\n   */\n  propertyNames?: JSONSchema;\n\n  /**\n   * The value of this keyword MUST be a boolean. When multiple occurrences\n   * of this keyword are applicable to a single sub-instance, the resulting\n   * value MUST be `true` if any occurrence specifies a `true` value, and\n   * MUST be `false` otherwise.\n   *\n   * If `readOnly` has a value of boolean `true`, it indicates that the\n   * value of the instance is managed exclusively by the owning authority,\n   * and attempts by an application to modify the value of this property are\n   * expected to be ignored or rejected by that owning authority.\n   *\n   * An instance document that is marked as `readOnly` for the entire\n   * document MAY be ignored if sent to the owning authority, or MAY result\n   * in an error, at the authority's discretion.\n   *\n   * For example, `readOnly` would be used to mark a database-generated\n   * serial number as read-only.\n   *\n   * This keyword can be used to assist in user interface instance\n   * generation.\n   *\n   * @default false\n   */\n  readOnly?: boolean;\n\n  /**\n   * The value of this keyword MUST be an array. Elements of this array, if\n   * any, MUST be strings, and MUST be unique.\n   *\n   * An object instance is valid against this keyword if every item in the\n   * array is the name of a property in the instance.\n   *\n   * Omitting this keyword has the same behavior as an empty array.\n   */\n  required?: MaybeReadonlyArray<string>;\n\n  /**\n   * This keyword's value MUST be a valid JSON Schema.\n   *\n   * When `if` is present, and the instance successfully validates against\n   * its subschema, then validation succeeds against this keyword if the\n   * instance also successfully validates against this keyword's subschema.\n   *\n   * This keyword has no effect when `if` is absent, or when the instance\n   * fails to validate against its subschema. Implementations MUST NOT\n   * evaluate the instance against this keyword, for either validation or\n   * annotation collection purposes, in such cases.\n   */\n  then?: JSONSchema<Value, SchemaType>;\n\n  /**\n   * Can be used to decorate a user interface with a short label about the\n   * data produced.\n   */\n  title?: string;\n\n  /**\n   * The value of this keyword MUST be either a string or an array. If it is\n   * an array, elements of the array MUST be strings and MUST be unique.\n   *\n   * String values MUST be one of the six primitive types (`\"null\"`,\n   * `\"boolean\"`, `\"object\"`, `\"array\"`, `\"number\"`, or\n   * `\"string\"`), or `\"integer\"` which matches any number with a zero\n   * fractional part.\n   *\n   * An instance validates if and only if the instance is in any of the sets\n   * listed for this keyword.\n   */\n  type?: SchemaType;\n\n  /**\n   * The value of `unevaluatedItems` MUST be a valid JSON Schema.\n   *\n   * The behavior of this keyword depends on the annotation results of\n   * adjacent keywords that apply to the instance location being validated.\n   * Specifically, the annotations from `prefixItems`, `items`, and\n   * `contains`, which can come from those keywords when they are adjacent\n   * to the `unevaluatedItems` keyword. Those three annotations, as well as\n   * `unevaluatedItems`, can also result from any and all adjacent\n   * [in-place applicator][in-place-applicator] keywords.\n   *\n   * If no relevant annotations are present, the `unevaluatedItems`\n   * subschema MUST be applied to all locations in the array.\n   * If a boolean `true` value is present from any of the relevant\n   * annotations, `unevaluatedItems` MUST be ignored.  Otherwise, the\n   * subschema MUST be applied to any index greater than the largest\n   * annotation value for `prefixItems`, which does not appear in any\n   * annotation value for `contains`.\n   *\n   * This means that `prefixItems`, `items`, `contains`, and all\n   * in-place applicators MUST be evaluated before this keyword can be\n   * evaluated. Authors of extension keywords MUST NOT define an in-place\n   * applicator that would need to be evaluated after this keyword.\n   *\n   * If the `unevaluatedItems` subschema is applied to any positions within\n   * the instance array, it produces an annotation result of boolean\n   * `true`, analogous to the behavior of `items`.\n   *\n   * Omitting this keyword has the same assertion behavior as an empty\n   * schema.\n   *\n   * [in-place-applicator]: https://json-schema.org/draft/2020-12/json-schema-core.html#in-place\n   */\n  unevaluatedItems?: JSONSchema;\n\n  /**\n   * The value of `unevaluatedProperties` MUST be a valid JSON Schema.\n   *\n   * The behavior of this keyword depends on the annotation results of\n   * adjacent keywords that apply to the instance location being validated.\n   * Specifically, the annotations from `properties`,\n   * `patternProperties`, and `additionalProperties`, which can come from\n   * those keywords when they are adjacent to the `unevaluatedProperties`\n   * keyword.  Those three annotations, as well as `unevaluatedProperties`,\n   * can also result from any and all adjacent\n   * [in-place applicator][in-place-applicator] keywords.\n   *\n   * Validation with `unevaluatedProperties` applies only to the child\n   * values of instance names that do not appear in the `properties`,\n   * `patternProperties`, `additionalProperties`, or\n   * `unevaluatedProperties` annotation results that apply to the\n   * instance location being validated.\n   *\n   * For all such properties, validation succeeds if the child instance\n   * validates against the \"unevaluatedProperties\" schema.\n   *\n   * This means that `properties`, `patternProperties`,\n   * `additionalProperties`, and all in-place applicators MUST be evaluated\n   * before this keyword can be evaluated.  Authors of extension keywords\n   * MUST NOT define an in-place applicator that would need to be evaluated\n   * after this keyword.\n   *\n   * The annotation result of this keyword is the set of instance property\n   * names validated by this keyword's subschema.\n   *\n   * Omitting this keyword has the same assertion behavior as an empty\n   * schema.\n   *\n   * [in-place-applicator]: https://json-schema.org/draft/2020-12/json-schema-core.html#in-place\n   */\n  unevaluatedProperties?: JSONSchema;\n\n  /**\n   * The value of this keyword MUST be a boolean.\n   *\n   * If this keyword has boolean value `false`, the instance validates\n   * successfully. If it has boolean value `true`, the instance validates\n   * successfully if all of its elements are unique.\n   *\n   * Omitting this keyword has the same behavior as a value of `false`.\n   *\n   * @default false\n   */\n  uniqueItems?: boolean;\n\n  /**\n   * The value of this keyword MUST be a boolean. When multiple occurrences\n   * of this keyword is applicable to a single sub-instance, the resulting\n   * value MUST be `true` if any occurrence specifies a `true` value, and\n   * MUST be `false` otherwise.\n   *\n   * If `writeOnly` has a value of boolean `true`, it indicates that the\n   * value is never present when the instance is retrieved from the owning\n   * authority. It can be present when sent to the owning authority to update\n   * or create the document (or the resource it represents), but it will not\n   * be included in any updated or newly created version of the instance.\n   *\n   * An instance document that is marked as `writeOnly` for the entire\n   * document MAY be returned as a blank document of some sort, or MAY\n   * produce an error upon retrieval, or have the retrieval request ignored,\n   * at the authority's discretion.\n   *\n   * For example, `writeOnly` would be used to mark a password input field.\n   *\n   * These keywords can be used to assist in user interface instance\n   * generation. In particular, an application MAY choose to use a widget\n   * that hides input values as they are typed for write-only fields.\n   *\n   * @default false\n   */\n  writeOnly?: boolean;\n};\n\n// -----------------------------------------------------------------------------\n\nexport namespace JSONSchema {\n  export type TypeValue = (\n    | ValueOf<TypeName>\n    | TypeName\n    | Array<ValueOf<TypeName> | TypeName>\n    | ReadonlyArray<ValueOf<TypeName> | TypeName>\n  );\n\n  /**\n   * JSON Schema interface\n   */\n  export type Interface<\n    Value = any,\n    SchemaType extends TypeValue = TypeValue,\n  > = Exclude<\n    JSONSchema<Value, SchemaType>,\n    boolean\n  >;\n\n  export type Array<T = any> = Pick<\n    Interface<T, \"array\">,\n    KeywordByType.Any | KeywordByType.Array\n  >;\n\n  export type Boolean = Pick<\n    Interface<boolean, \"boolean\">,\n    KeywordByType.Any\n  >;\n\n  export type Integer = Pick<\n    Interface<number, \"integer\">,\n    KeywordByType.Any | KeywordByType.Number\n  >;\n\n  export type Number = Pick<\n    Interface<number, \"number\">,\n    KeywordByType.Any | KeywordByType.Number\n  >;\n\n  export type Null = Pick<\n    Interface<null, \"null\">,\n    KeywordByType.Any\n  >;\n\n  export type Object<T = any> = Pick<\n    Interface<T, \"object\">,\n    KeywordByType.Any | KeywordByType.Object\n  >;\n\n  export type String = Pick<\n    Interface<string, \"string\">,\n    KeywordByType.Any | KeywordByType.String\n  >;\n}\n\nnamespace KeywordByType {\n  export type Any =\n    | \"$anchor\"\n    | \"$comment\"\n    | \"$defs\"\n    | \"$dynamicAnchor\"\n    | \"$dynamicRef\"\n    | \"$id\"\n    | \"$ref\"\n    | \"$schema\"\n    | \"$vocabulary\"\n    | \"allOf\"\n    | \"anyOf\"\n    | \"const\"\n    | \"default\"\n    | \"definitions\"\n    | \"deprecated\"\n    | \"description\"\n    | \"else\"\n    | \"enum\"\n    | \"examples\"\n    | \"format\"\n    | \"if\"\n    | \"not\"\n    | \"oneOf\"\n    | \"readOnly\"\n    | \"then\"\n    | \"title\"\n    | \"type\"\n    | \"writeOnly\";\n\n  export type Array =\n    | \"additionalItems\"\n    | \"contains\"\n    | \"items\"\n    | \"maxContains\"\n    | \"maxItems\"\n    | \"minContains\"\n    | \"minItems\"\n    | \"prefixItems\"\n    | \"unevaluatedItems\"\n    | \"uniqueItems\";\n\n  export type Number =\n    | \"exclusiveMaximum\"\n    | \"exclusiveMinimum\"\n    | \"maximum\"\n    | \"minimum\"\n    | \"multipleOf\";\n\n  export type Object =\n    | \"additionalProperties\"\n    | \"dependencies\"\n    | \"dependentRequired\"\n    | \"dependentSchemas\"\n    | \"maxProperties\"\n    | \"minProperties\"\n    | \"patternProperties\"\n    | \"properties\"\n    | \"propertyNames\"\n    | \"required\"\n    | \"unevaluatedProperties\";\n\n  export type String =\n    | \"contentEncoding\"\n    | \"contentMediaType\"\n    | \"contentSchema\"\n    | \"maxLength\"\n    | \"minLength\"\n    | \"pattern\";\n}\n\n// -----------------------------------------------------------------------------\n\n/**\n * Content encoding strategy enum.\n *\n * - [Content-Transfer-Encoding Syntax](https://datatracker.ietf.org/doc/html/rfc2045#section-6.1)\n * - [7bit vs 8bit encoding](https://stackoverflow.com/questions/25710599/content-transfer-encoding-7bit-or-8-bit/28531705#28531705)\n */\nexport enum ContentEncoding {\n  /**\n   * Only US-ASCII characters, which use the lower 7 bits for each character.\n   *\n   * Each line must be less than 1,000 characters.\n   */\n  \"7bit\" = \"7bit\",\n\n  /**\n   * Allow extended ASCII characters which can use the 8th (highest) bit to\n   * indicate special characters not available in 7bit.\n   *\n   * Each line must be less than 1,000 characters.\n   */\n  \"8bit\" = \"8bit\",\n\n  /**\n   * Useful for data that is mostly non-text.\n   */\n  Base64 = \"base64\",\n\n  /**\n   * Same character set as 8bit, with no line length restriction.\n   */\n  Binary = \"binary\",\n\n  /**\n   * An extension token defined by a standards-track RFC and registered with\n   * IANA.\n   */\n  IETFToken = \"ietf-token\",\n\n  /**\n   * Lines are limited to 76 characters, and line breaks are represented using\n   * special characters that are escaped.\n   */\n  QuotedPrintable = \"quoted-printable\",\n\n  /**\n   * The two characters \"X-\" or \"x-\" followed, with no intervening white space,\n   * by any token.\n   */\n  XToken = \"x-token\",\n}\n\n/**\n * This enum provides well-known formats that apply to strings.\n */\nexport enum Format {\n  /**\n   * A string instance is valid against this attribute if it is a valid\n   * representation according to the \"full-date\" production in\n   * [RFC 3339][RFC3339].\n   *\n   * [RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339\n   */\n  Date = \"date\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid\n   * representation according to the \"date-time\" production in\n   * [RFC 3339][RFC3339].\n   *\n   * [RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339\n   */\n  DateTime = \"date-time\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid\n   * representation according to the \"duration\" production.\n   */\n  Duration = \"duration\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid Internet\n   * email address as defined by by the \"Mailbox\" ABNF rule in [RFC\n   * 5321][RFC5322], section 4.1.2.\n   *\n   * [RFC5321]: https://datatracker.ietf.org/doc/html/rfc5321\n   */\n  Email = \"email\",\n\n  /**\n   * As defined by [RFC 1123, section 2.1][RFC1123], including host names\n   * produced using the Punycode algorithm specified in\n   * [RFC 5891, section 4.4][RFC5891].\n   *\n   * [RFC1123]: https://datatracker.ietf.org/doc/html/rfc1123\n   * [RFC5891]: https://datatracker.ietf.org/doc/html/rfc5891\n   */\n  Hostname = \"hostname\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid Internet\n   * email address as defined by the extended \"Mailbox\" ABNF rule in\n   * [RFC 6531][RFC6531], section 3.3.\n   *\n   * [RFC6531]: https://datatracker.ietf.org/doc/html/rfc6531\n   */\n  IDNEmail = \"idn-email\",\n\n  /**\n   * As defined by either [RFC 1123, section 2.1][RFC1123] as for hostname, or\n   * an internationalized hostname as defined by\n   * [RFC 5890, section 2.3.2.3][RFC5890].\n   *\n   * [RFC1123]: https://datatracker.ietf.org/doc/html/rfc1123\n   * [RFC5890]: https://datatracker.ietf.org/doc/html/rfc5890\n   */\n  IDNHostname = \"idn-hostname\",\n\n  /**\n   * An IPv4 address according to the \"dotted-quad\" ABNF syntax as defined in\n   * [RFC 2673, section 3.2][RFC2673].\n   *\n   * [RFC2673]: https://datatracker.ietf.org/doc/html/rfc2673\n   */\n  IPv4 = \"ipv4\",\n\n  /**\n   * An IPv6 address as defined in [RFC 4291, section 2.2][RFC4291].\n   *\n   * [RFC4291]: https://datatracker.ietf.org/doc/html/rfc4291\n   */\n  IPv6 = \"ipv6\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid IRI,\n   * according to [RFC 3987][RFC3987].\n   *\n   * [RFC3987]: https://datatracker.ietf.org/doc/html/rfc3987\n   */\n  IRI = \"iri\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid IRI\n   * Reference (either an IRI or a relative-reference), according to\n   * [RFC 3987][RFC3987].\n   *\n   * [RFC3987]: https://datatracker.ietf.org/doc/html/rfc3987\n   */\n  IRIReference = \"iri-reference\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid JSON\n   * string representation of a JSON Pointer, according to\n   * [RFC 6901, section 5][RFC6901].\n   *\n   * [RFC6901]: https://datatracker.ietf.org/doc/html/rfc6901\n   */\n  JSONPointer = \"json-pointer\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid JSON\n   * string representation of a JSON Pointer fragment, according to\n   * [RFC 6901, section 5][RFC6901].\n   *\n   * [RFC6901]: https://datatracker.ietf.org/doc/html/rfc6901\n   */\n  JSONPointerURIFragment = \"json-pointer-uri-fragment\",\n\n  /**\n   * This attribute applies to string instances.\n   *\n   * A regular expression, which SHOULD be valid according to the\n   * [ECMA-262][ecma262] regular expression dialect.\n   *\n   * Implementations that validate formats MUST accept at least the subset of\n   * [ECMA-262][ecma262] defined in the [Regular Expressions][regexInterop]\n   * section of this specification, and SHOULD accept all valid\n   * [ECMA-262][ecma262] expressions.\n   *\n   * [ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\n   * [regexInterop]: https://json-schema.org/draft/2020-12/json-schema-validation.html#regexInterop\n   */\n  RegEx = \"regex\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid\n   * [Relative JSON Pointer][relative-json-pointer].\n   *\n   * [relative-json-pointer]: https://datatracker.ietf.org/doc/html/draft-handrews-relative-json-pointer-01\n   */\n  RelativeJSONPointer = \"relative-json-pointer\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid\n   * representation according to the \"time\" production in [RFC 3339][RFC3339].\n   *\n   * [RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339\n   */\n  Time = \"time\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid URI,\n   * according to [RFC3986][RFC3986].\n   *\n   * [RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986\n   */\n  URI = \"uri\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid URI\n   * Reference (either a URI or a relative-reference), according to\n   * [RFC3986][RFC3986].\n   *\n   * [RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986\n   */\n  URIReference = \"uri-reference\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid URI\n   * Template (of any level), according to [RFC 6570][RFC6570].\n   *\n   * Note that URI Templates may be used for IRIs; there is no separate IRI\n   * Template specification.\n   *\n   * [RFC6570]: https://datatracker.ietf.org/doc/html/rfc6570\n   */\n  URITemplate = \"uri-template\",\n\n  /**\n   * A string instance is valid against this attribute if it is a valid string\n   * representation of a UUID, according to [RFC 4122][RFC4122].\n   *\n   * [RFC4122]: https://datatracker.ietf.org/doc/html/rfc4122\n   */\n  UUID = \"uuid\",\n}\n\n/**\n * Enum consisting of simple type names for the `type` keyword\n */\nexport enum TypeName {\n  /**\n   * Value MUST be an array.\n   */\n  Array = \"array\",\n\n  /**\n   * Value MUST be a boolean.\n   */\n  Boolean = \"boolean\",\n\n  /**\n   * Value MUST be an integer, no floating point numbers are allowed. This is a\n   * subset of the number type.\n   */\n  Integer = \"integer\",\n\n  /**\n   * Value MUST be null. Note this is mainly for purpose of being able use union\n   * types to define nullability. If this type is not included in a union, null\n   * values are not allowed (the primitives listed above do not allow nulls on\n   * their own).\n   */\n  Null = \"null\",\n\n  /**\n   * Value MUST be a number, floating point numbers are allowed.\n   */\n  Number = \"number\",\n\n  /**\n   * Value MUST be an object.\n   */\n  Object = \"object\",\n\n  /**\n   * Value MUST be a string.\n   */\n  String = \"string\",\n}\n\n// -----------------------------------------------------------------------------\n// Keywords\n// -----------------------------------------------------------------------------\n\nexport const keywords = [\n  \"$anchor\",\n  \"$comment\",\n  \"$defs\",\n  \"$dynamicAnchor\",\n  \"$dynamicRef\",\n  \"$id\",\n  \"$ref\",\n  \"$schema\",\n  \"$vocabulary\",\n  \"additionalItems\",\n  \"additionalProperties\",\n  \"allOf\",\n  \"anyOf\",\n  \"const\",\n  \"contains\",\n  \"contentEncoding\",\n  \"contentMediaType\",\n  \"contentSchema\",\n  \"default\",\n  \"definitions\",\n  \"dependencies\",\n  \"dependentRequired\",\n  \"dependentSchemas\",\n  \"deprecated\",\n  \"description\",\n  \"else\",\n  \"enum\",\n  \"examples\",\n  \"exclusiveMaximum\",\n  \"exclusiveMinimum\",\n  \"format\",\n  \"if\",\n  \"items\",\n  \"maxContains\",\n  \"maximum\",\n  \"maxItems\",\n  \"maxLength\",\n  \"maxProperties\",\n  \"minContains\",\n  \"minimum\",\n  \"minItems\",\n  \"minLength\",\n  \"minProperties\",\n  \"multipleOf\",\n  \"not\",\n  \"oneOf\",\n  \"pattern\",\n  \"patternProperties\",\n  \"prefixItems\",\n  \"properties\",\n  \"propertyNames\",\n  \"readOnly\",\n  \"required\",\n  \"then\",\n  \"title\",\n  \"type\",\n  \"unevaluatedItems\",\n  \"unevaluatedProperties\",\n  \"uniqueItems\",\n  \"writeOnly\",\n] as const;\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { NonBooleanJsfSchema } from '../types'\nimport { Format } from 'json-schema-typed/draft-2020-12'\n\n/**\n * Format validation error type\n * @description\n * According to JSON Schema 2020-12:\n * - Format validation is an annotation by default\n * - Format validation only applies to strings\n * - Unknown formats should be ignored\n * - Implementations SHOULD implement validation for standard formats\n * - Implementations MAY treat format as a no-op\n */\nexport type FormatValidationErrorType = 'format'\n\n/**\n * Regular expression patterns for format validation\n * These patterns are based on JSON Schema 2020-12 specifications\n */\nconst PATTERNS = {\n  // Date/Time patterns (RFC 3339)\n  DATE_TIME: /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$/,\n  DATE: /^\\d{4}-\\d{2}-\\d{2}$/,\n  TIME: /^(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[+-](?:[01]\\d|2[0-3]):[0-5]\\d)$/,\n\n  // Duration (ISO 8601)\n  DURATION: /^P(?!$)(?:\\d+Y)?(?:\\d+M)?(?:\\d+D)?(?:T(?=\\d)(?:\\d+H)?(?:\\d+M)?(?:\\d+S)?)?$/,\n\n  // Email patterns\n  EMAIL:\n    /^[\\w.!#$%&'*+/=?^`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n  IDN_EMAIL: /^[^\\s@]+@[^\\s@][^\\s.@]*\\.[^\\s@]+$/,\n\n  // Host patterns\n  HOSTNAME: /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$/i,\n  IDN_HOSTNAME: /^[^\\s._-].*[^\\s._-]$/,\n\n  // IP address patterns\n  IPV6_PART: /^[0-9a-f]{1,4}$/i,\n\n  // URI/IRI patterns\n  PROTOCOL: /^[a-z]+:/,\n  URI_REFERENCE: /^\\S*$/,\n\n  // UUID pattern (RFC 4122)\n  UUID: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,\n\n  // JSON Pointer patterns\n  JSON_POINTER: /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n  JSON_POINTER_URI_FRAGMENT: /^#(?:\\/(?:[\\w\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n  RELATIVE_JSON_POINTER: /^(?:0|[1-9]\\d*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\n  // URI Template (RFC 6570)\n  URI_TEMPLATE:\n    /^(?:[!#$&'()*+,/:;=?@\\w\\-.~]|%[0-9a-f]{2}|\\{[+#./;?&=,!@|]?(?:\\w|%[0-9a-f]{2})+(?::[1-9]\\d{0,3}|\\*)?(?:,(?:\\w|%[0-9a-f]{2})+(?::[1-9]\\d{0,3}|\\*)?)*\\})*$/i,\n} as const\n\n/**\n * Built-in format validators according to JSON Schema 2020-12\n */\nconst formatValidationFunctions: Record<Format, (value: string) => boolean> = {\n  [Format.DateTime]: value => PATTERNS.DATE_TIME.test(value),\n  [Format.Date]: value => PATTERNS.DATE.test(value),\n  [Format.Time]: value => PATTERNS.TIME.test(value),\n  [Format.Duration]: value => PATTERNS.DURATION.test(value),\n  [Format.Email]: (value) => {\n    // Basic email validation with length limit (RFC 5321)\n    return value.length <= 254 && PATTERNS.EMAIL.test(value)\n  },\n  [Format.IDNEmail]: (value) => {\n    // More permissive email validation for IDN with length limit\n    return value.length <= 254 && PATTERNS.IDN_EMAIL.test(value)\n  },\n  [Format.Hostname]: (value) => {\n    if (value.length > 255) {\n      return false\n    }\n    const labels = value.split('.')\n    return labels.every(label => PATTERNS.HOSTNAME.test(label))\n  },\n  [Format.IDNHostname]: (value) => {\n    if (value.length > 255) {\n      return false\n    }\n    const labels = value.split('.')\n    return labels.every(label => label.length <= 63 && PATTERNS.IDN_HOSTNAME.test(label))\n  },\n  [Format.IPv4]: (value) => {\n    const parts = value.split('.')\n    if (parts.length !== 4) {\n      return false\n    }\n    return parts.every((part) => {\n      const num = Number.parseInt(part, 10)\n      return num >= 0 && num <= 255 && part === num.toString()\n    })\n  },\n  [Format.IPv6]: (value) => {\n    const parts = value.split(':')\n    if (parts.length > 8) {\n      return false\n    }\n    let hasDoubleColon = false\n    return parts.every((part) => {\n      if (part === '') {\n        if (hasDoubleColon) {\n          return false\n        }\n        hasDoubleColon = true\n        return true\n      }\n      return PATTERNS.IPV6_PART.test(part)\n    })\n  },\n  [Format.URI]: (value) => {\n    try {\n      const url = new URL(value)\n      return url.protocol !== '' && PATTERNS.PROTOCOL.test(url.protocol)\n    }\n    catch {\n      return false\n    }\n  },\n  [Format.URIReference]: (value) => {\n    try {\n      if (value.startsWith('//')) {\n        return PATTERNS.URI_REFERENCE.test(value.slice(2))\n      }\n      void new URL(value, 'http://example.com')\n      return true\n    }\n    catch {\n      return false\n    }\n  },\n  [Format.IRI]: (value) => {\n    try {\n      const url = new URL(value)\n      return url.protocol !== '' && PATTERNS.PROTOCOL.test(url.protocol)\n    }\n    catch {\n      return false\n    }\n  },\n  [Format.IRIReference]: (value) => {\n    try {\n      if (value.startsWith('//')) {\n        return PATTERNS.URI_REFERENCE.test(value.slice(2))\n      }\n      void new URL(value, 'http://example.com')\n      return true\n    }\n    catch {\n      return false\n    }\n  },\n  [Format.RegEx]: (value) => {\n    try {\n      void new RegExp(value, 'u')\n      return true\n    }\n    catch {\n      return false\n    }\n  },\n  [Format.UUID]: value => PATTERNS.UUID.test(value),\n  [Format.JSONPointer]: value => PATTERNS.JSON_POINTER.test(value),\n  [Format.JSONPointerURIFragment]: value => PATTERNS.JSON_POINTER_URI_FRAGMENT.test(value),\n  [Format.RelativeJSONPointer]: value => PATTERNS.RELATIVE_JSON_POINTER.test(value),\n  [Format.URITemplate]: value => PATTERNS.URI_TEMPLATE.test(value),\n}\n\n/**\n * Validate a string value against a format\n * @param value - The string value to validate\n * @param schema - The schema to validate against\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * According to JSON Schema 2020-12:\n * - Format validation is an annotation by default\n * - Format validation only applies to strings\n * - Unknown formats should be ignored\n * - Implementations SHOULD implement validation for standard formats\n * - Implementations MAY treat format as a no-op\n */\nexport function validateFormat(\n  value: string,\n  schema: NonBooleanJsfSchema,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  const errors: ValidationError[] = []\n\n  // Format validation only applies to strings\n  if (typeof value !== 'string') {\n    return errors\n  }\n\n  const validateFn = formatValidationFunctions[schema.format as Format]\n  if (validateFn && !validateFn(value)) {\n    errors.push({ path, validation: 'format', schema, value })\n  }\n\n  return errors\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { validateFormat } from './format'\nimport { getSchemaType } from './schema'\n\n/**\n * Validate a string against a schema\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * Implements string validation according to JSON Schema 2020-12:\n * - Length validation (minLength, maxLength)\n * - Pattern validation (pattern)\n * - Format validation (as annotation by default)\n */\nexport function validateString(\n  value: SchemaValue,\n  schema: NonBooleanJsfSchema,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  const errors: ValidationError[] = []\n  const schemaType = getSchemaType(schema)\n\n  if (typeof value !== 'string') {\n    return []\n  }\n\n  if (schemaType !== undefined && schemaType !== 'string') {\n    return []\n  }\n\n  const valueLength = [...new Intl.Segmenter().segment(value)].length\n\n  // Length validation\n  if (schema.minLength !== undefined && valueLength < schema.minLength) {\n    errors.push({ path, validation: 'minLength', schema, value })\n  }\n\n  if (schema.maxLength !== undefined && valueLength > schema.maxLength) {\n    errors.push({ path, validation: 'maxLength', schema, value })\n  }\n\n  // Pattern validation\n  if (schema.pattern !== undefined) {\n    const pattern = new RegExp(schema.pattern)\n    if (!pattern.test(value)) {\n      errors.push({ path, validation: 'pattern', schema, value })\n    }\n  }\n\n  // Format validation (annotation by default in 2020-12)\n  if (schema.format !== undefined) {\n    const formatErrors = validateFormat(value, schema, path)\n    errors.push(...formatErrors)\n  }\n\n  return errors\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { JsfSchema, JsfSchemaType, JsonLogicContext, JsonLogicRootSchema, SchemaValue } from '../types'\nimport { validateArray } from './array'\nimport { validateAllOf, validateAnyOf, validateNot, validateOneOf } from './composition'\nimport { validateCondition } from './conditions'\nimport { validateConst } from './const'\nimport { validateDate } from './custom/date'\nimport { validateEnum } from './enum'\nimport { validateFile } from './file'\nimport { getJsonLogicContextFromSchema, validateJsonLogicRules } from './json-logic'\nimport { validateNumber } from './number'\nimport { validateObject } from './object'\nimport { validateString } from './string'\nimport { isObjectValue } from './util'\n\nexport interface LegacyOptions {\n  /**\n   * A null value will be treated as undefined.\n   * When true, providing a value to a schema that is `false`,\n   * the validation will succeed instead of returning a type error.\n   * This was a bug in v0, we fixed it in v1. If you need the same wrong behavior, set this to true.\n   * @default false\n   * @example\n   * ```ts\n   * Schema: { \"properties\": { \"name\": { \"type\": \"string\" } } }\n   * Value: { \"name\": null } // Validation succeeds, even though the type is not 'null'\n   * ```\n   */\n  treatNullAsUndefined?: boolean\n  /**\n   * A value against a schema \"false\" will be allowed.\n   * When true, providing a value to a non-required field that is not of type 'null' or ['null']\n   * the validation will succeed instead of returning a type error.\n   * This was a bug in v0, we fixed it in v1. If you need the same wrong behavior, set this to true.\n   * @default false\n   * @example\n   * ```ts\n   * Schema: { \"properties\": { \"age\": false } }\n   * Value: { age: 10 } // Validation succeeds, even though the value is forbidden;\n   * ```\n   */\n  allowForbiddenValues?: boolean\n}\n\n/**\n * Get the type of a schema\n * @param schema - The schema to get the type of\n * @returns The type of the schema, or an array of types if the schema is an array.\n * If no type is defined, returns undefined.\n *\n * IMPORTANT:\n * We intentionally return 'undefined' (instead of defaulting to 'object') when no type is defined.\n * In JSON Schema 2020-12, an absent \"type\" keyword means there is no type constraint.\n * This change prevents erroneously enforcing a default type of 'object', which was causing false negatives\n * (e.g. when validating an \"anyOf\" schema without a \"type\").\n */\nexport function getSchemaType(schema: JsfSchema): JsfSchemaType | JsfSchemaType[] | undefined {\n  if (typeof schema === 'boolean') {\n    return 'boolean'\n  }\n\n  if (schema.type !== undefined) {\n    return schema.type\n  }\n\n  return undefined\n}\n\n/**\n * Validate the type of a value against a schema\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * When getSchemaType returns undefined, this function skips type validation.\n * This aligns with JSON Schema 2020-12 semantics: if no type is provided, no type check is enforced.\n */\nfunction validateType(\n  value: SchemaValue,\n  schema: JsfSchema,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  const schemaType = getSchemaType(schema)\n\n  // Skip type-checking if no type is specified.\n  if (schemaType === undefined) {\n    return []\n  }\n\n  if (schemaType === 'null' && value === null) {\n    return []\n  }\n\n  const valueType = value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value\n\n  if (Array.isArray(schemaType)) {\n    // Handle cases where schema type is an array (e.g., [\"string\", \"null\"])\n    if (value === null && schemaType.includes('null')) {\n      return []\n    }\n\n    for (const type of schemaType) {\n      if (type === 'array' && Array.isArray(value)) {\n        return [] // Correctly validate array type\n      }\n      if (valueType === 'number' && type === 'integer' && Number.isInteger(value)) {\n        return []\n      }\n      if (valueType === type || (type === 'null' && value === null)) {\n        return []\n      }\n    }\n  }\n  else {\n    // Handle cases where schema type is a single type string\n    if (schemaType === 'array' && Array.isArray(value)) {\n      return [] // Correctly validate array type\n    }\n    if (valueType === 'number' && schemaType === 'integer' && Number.isInteger(value)) {\n      return []\n    }\n    if (valueType === schemaType) {\n      return []\n    }\n  }\n\n  // If none of the conditions matched, it's a type error\n  return [{ path, validation: 'type', schema, value }]\n}\n\n/**\n * Validate a value against a json-logic schema (inner conditions inside a 'x-jsf-logic' property)\n * Note: for this validator, the schema might be absent, so we return early in that case.\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param options - The validation options\n * @param path - The path to the current field being validated\n * @param jsonLogicContext - The json-logic context\n * @returns An array of validation errors\n */\nfunction validateJsonLogicSchema(value: SchemaValue, schema: JsfSchema | undefined, options: LegacyOptions = {}, path: ValidationErrorPath = [], jsonLogicContext?: JsonLogicContext): ValidationError[] {\n  if (!schema) {\n    return []\n  }\n\n  return validateSchema(value, schema, options, path, jsonLogicContext)\n}\n\ninterface CompiledPattern { regex: RegExp }\n\nfunction compilePatternProperties(patternProperties: Record<string, any> = {}): CompiledPattern[] {\n  return Object.keys(patternProperties).map(\n    pattern => ({ regex: new RegExp(pattern) }),\n  )\n}\n\n/**\n * Validate a value against a schema\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @param options - The validation options\n * @param path - The path to the current field being validated\n * @returns An array of validation errors\n * @description\n * This function is the main validation function that implements JSON Schema validation.\n * The validation process follows this order:\n * 1. Handle undefined values and the required constraint\n * 2. Handle boolean schemas (true allows everything, false allows nothing)\n * 3. Validate against base schema constraints:\n *    - Type validation (if type is specified)\n *    - Required properties\n *    - Boolean validation\n *    - Enum validation\n *    - Const validation\n *    - Type-specific validations (string, number, object)\n * 4. Validate against composition keywords in this order:\n *    - not (negates the validation of a subschema)\n *    - allOf (all subschemas must be valid)\n *    - anyOf (at least one subschema must be valid)\n *    - oneOf (exactly one subschema must be valid)\n *\n * @see validateType - For type validation behavior\n * @see validateSchemaWithoutComposition - For base schema validation\n * @see https://json-schema.org/understanding-json-schema/reference/combining.html\n */\nexport function validateSchema(\n  value: SchemaValue,\n  schema: JsfSchema,\n  options: LegacyOptions = {},\n  path: ValidationErrorPath = [],\n  rootJsonLogicContext?: JsonLogicContext,\n): ValidationError[] {\n  let jsonLogicContext = rootJsonLogicContext\n  let jsonLogicRootSchema: JsonLogicRootSchema | undefined\n\n  // If we have a root jsonLogicContext, we should use that.\n  // If not, it probably means the current schema is the root schema (or that there's no json-logic node in the current schema)\n  if (!rootJsonLogicContext && schema['x-jsf-logic']) {\n    // - We should set the jsonLogicContext's schema as the schema in the 'x-jsf-logic' property\n    jsonLogicContext = getJsonLogicContextFromSchema(schema['x-jsf-logic'], value)\n\n    // - We need to validate any schema that's in the 'x-jsf-logic' property, like if/then/else/allOf/etc.\n    // This is done below in the validateJsonLogicSchema call.\n    const { validations, computedValues, ...rest } = schema['x-jsf-logic']\n    jsonLogicRootSchema = rest\n  }\n\n  const valueIsUndefined = value === undefined || (value === null && options.treatNullAsUndefined)\n  const errors: ValidationError[] = []\n\n  // Handle undefined value\n  if (valueIsUndefined) {\n    return []\n  }\n\n  // Handle boolean schemas\n  if (typeof schema === 'boolean') {\n    // When the boolean schema is false, we will return an error, but only when forbidden values are not explicitly\n    // allowed per the allowForbiddenValues option.\n    if (!schema && !options.allowForbiddenValues) {\n      return [{ path, validation: 'forbidden', schema, value }]\n    }\n    return []\n  }\n\n  // Check if it is a file input (needed early for null check)\n  const presentation = schema['x-jsf-presentation']\n  const isExplicitFileInput = presentation?.inputType === 'file'\n\n  let typeValidationErrors: ValidationError[] = []\n  // Skip standard type validation ONLY if inputType is explicitly 'file'\n  // (The null check above already handled null for potential file inputs)\n  if (!isExplicitFileInput) {\n    typeValidationErrors = validateType(value, schema, path)\n    if (typeValidationErrors.length > 0) {\n      return typeValidationErrors\n    }\n  }\n\n  // If the schema defines \"required\", run required checks even when type is undefined.\n  if (schema.required && isObjectValue(value)) {\n    const missingKeys = schema.required.filter((key: string) => {\n      const fieldValue = value[key]\n      // Field is considered missing if:\n      // - it's undefined OR\n      // - it's null AND treatNullAsUndefined option is true\n      // - it's an array/object and it's empty\n      if (Array.isArray(fieldValue)) {\n        return fieldValue.length === 0\n      }\n\n      if (isObjectValue(fieldValue)) {\n        return Object.keys(fieldValue).length === 0\n      }\n\n      return fieldValue === undefined || (fieldValue === null && options.treatNullAsUndefined)\n    })\n\n    for (const key of missingKeys) {\n      errors.push({\n        path: [...path, key],\n        validation: 'required',\n        schema: schema?.properties?.[key] || schema,\n        value,\n      })\n    }\n  }\n\n  if (schema.additionalProperties === false && isObjectValue(value)) {\n    const definedProps = new Set(Object.keys(schema.properties || {}))\n    const compiledPatterns = compilePatternProperties(schema.patternProperties)\n\n    for (const key of Object.keys(value)) {\n      const isDefined = definedProps.has(key)\n      const matchesPattern = compiledPatterns.some(({ regex }) => regex.test(key))\n\n      if (!isDefined && !matchesPattern) {\n        errors.push({\n          path: [...path, key],\n          validation: 'additionalProperties',\n          schema,\n          value: value[key],\n        })\n      }\n    }\n  }\n\n  return [\n    ...errors,\n    // JSON-schema spec validations\n    ...validateConst(value, schema, path),\n    ...validateEnum(value, schema, path),\n    ...validateObject(value, schema, options, jsonLogicContext, path),\n    ...validateArray(value, schema, options, jsonLogicContext, path),\n    ...validateString(value, schema, path),\n    ...validateNumber(value, schema, path),\n    // File validation\n    ...validateFile(value, schema, path),\n    // Composition and conditional logic\n    ...validateNot(value, schema, options, jsonLogicContext, path),\n    ...validateAllOf(value, schema, options, jsonLogicContext, path),\n    ...validateAnyOf(value, schema, options, jsonLogicContext, path),\n    ...validateOneOf(value, schema, options, jsonLogicContext, path),\n    ...validateCondition(value, schema, options, jsonLogicContext, path),\n    // Custom validations\n    ...validateDate(value, schema, options, path),\n    ...validateJsonLogicSchema(value, jsonLogicRootSchema, options, path, jsonLogicContext),\n    ...validateJsonLogicRules(schema, jsonLogicContext, path),\n  ]\n}\n","import type { ValidationError, ValidationErrorPath } from '../errors'\nimport type { LegacyOptions } from '../form'\nimport type { JsfSchema, JsonLogicContext, NonBooleanJsfSchema, SchemaValue } from '../types'\nimport { validateSchema } from './schema'\n\nexport function evaluateIfCondition(\n  value: SchemaValue,\n  ifNode: JsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath = [],\n): boolean {\n  // If a boolean value is used as a condition, we need to ignore the allowForbiddenValues option.\n  // Otherwise, we can't evaluate the condition correctly\n  const isTheConditionalABoolean = typeof ifNode === 'boolean'\n  const conditionIsTrue = validateSchema(value, ifNode, { ...options, ...(isTheConditionalABoolean ? { allowForbiddenValues: false } : {}) }, path, jsonLogicContext).length === 0\n\n  return conditionIsTrue\n}\n\nexport function validateCondition(\n  value: SchemaValue,\n  schema: NonBooleanJsfSchema,\n  options: LegacyOptions,\n  jsonLogicContext: JsonLogicContext | undefined,\n  path: ValidationErrorPath = [],\n): ValidationError[] {\n  if (schema.if === undefined) {\n    return []\n  }\n\n  // When evaluating a condition, we should ignore the allowForbiddenValues option as it will lead to wrong results\n  const conditionIsTrue = evaluateIfCondition(value, schema.if, options, jsonLogicContext, path)\n\n  if (conditionIsTrue && schema.then !== undefined) {\n    return validateSchema(value, schema.then, options, [...path, 'then'], jsonLogicContext)\n  }\n\n  if (!conditionIsTrue && schema.else !== undefined) {\n    return validateSchema(value, schema.else, options, [...path, 'else'], jsonLogicContext)\n  }\n\n  return []\n}\n","import type { Field } from './field/type'\nimport type { JsfObjectSchema, JsfSchema, JsonLogicContext, NonBooleanJsfSchema, ObjectValue, SchemaValue } from './types'\nimport type { LegacyOptions } from './validation/schema'\nimport { buildFieldSchema } from './field/schema'\nimport { deepMergeSchemas } from './utils'\nimport { evaluateIfCondition } from './validation/conditions'\nimport { applyComputedAttrsToSchema, getJsonLogicContextFromSchema } from './validation/json-logic'\nimport { validateSchema } from './validation/schema'\nimport { isObjectValue, safeDeepClone } from './validation/util'\n\n/**\n * Creates a new version of the schema with all the computed attrs applied, as well as the\n * final version of each property (taking into account conditional rules)\n * @param params - The parameters for the function\n * @param params.schema - The original schema\n * @param params.values - The current form values\n * @param params.options - Validation options\n * @returns The new schema\n */\nexport function calculateFinalSchema({\n  schema,\n  values,\n  options = {},\n}: {\n  schema: JsfObjectSchema\n  values: SchemaValue\n  options?: LegacyOptions\n}): JsfObjectSchema {\n  const jsonLogicContext = schema['x-jsf-logic'] ? getJsonLogicContextFromSchema(schema['x-jsf-logic'], values) : undefined\n  const schemaCopy = safeDeepClone(schema)\n\n  applySchemaRules(schemaCopy, values, options, jsonLogicContext)\n\n  if (jsonLogicContext?.schema.computedValues) {\n    applyComputedAttrsToSchema(schemaCopy, jsonLogicContext.schema.computedValues, values)\n    // If we had computed values applied to the schema,\n    // we need to re-apply the schema rules to update the fields\n    applySchemaRules(schemaCopy, values, options, jsonLogicContext)\n  }\n\n  return schemaCopy\n}\n\n/**\n * Evaluates the conditional rules for a field\n * @param values - The current field values\n * @param schema - The JSON schema definition\n * @param rule - Schema identifying the conditional rule\n * @param options - Validation options\n * @returns An object containing the rule and whether it matches\n */\nfunction evaluateConditional(\n  values: ObjectValue,\n  schema: JsfObjectSchema,\n  rule: NonBooleanJsfSchema,\n  options: LegacyOptions = {},\n  jsonLogicContext: JsonLogicContext | undefined,\n) {\n  // At this point, we know that the rule has an if property\n  const conditionIsTrue = evaluateIfCondition(values, rule.if!, options, jsonLogicContext)\n\n  // Prevent fields from being shown when required fields have type errors\n  let hasTypeErrors = false\n  if (conditionIsTrue && rule.if?.required) {\n    const requiredFields = rule.if.required\n    hasTypeErrors = requiredFields.some((fieldName) => {\n      if (!schema.properties || !schema.properties[fieldName]) {\n        return false\n      }\n      const fieldSchema = schema.properties[fieldName]\n      const fieldValue = values[fieldName]\n      const fieldErrors = validateSchema(fieldValue, fieldSchema, options)\n      return fieldErrors.some(error => error.validation === 'type')\n    })\n  }\n\n  return { rule, matches: conditionIsTrue && !hasTypeErrors }\n}\n\n/**\n * Applies JSON Schema conditional rules to determine updated field properties\n * @param schema - The JSON schema containing the rules\n * @param values - The current form values\n * @param options - Validation options\n * @param jsonLogicContext - JSON Logic context\n */\nfunction applySchemaRules(\n  schema: JsfObjectSchema,\n  values: SchemaValue = {},\n  options: LegacyOptions = {},\n  jsonLogicContext: JsonLogicContext | undefined,\n) {\n  if (!isObjectValue(values)) {\n    return\n  }\n\n  const conditionalRules: { rule: NonBooleanJsfSchema, matches: boolean }[] = []\n\n  // If the schema has an if property, evaluate it and add it to the conditional rules array\n  if (typeof schema.if !== 'undefined') {\n    conditionalRules.push(evaluateConditional(values, schema, schema, options, jsonLogicContext))\n  }\n\n  // If the schema has an allOf property, evaluate each rule and add it to the conditional rules array\n  (schema.allOf ?? [])\n    .filter((rule: JsfSchema) => typeof rule.if !== 'undefined')\n    .forEach((rule) => {\n      const result = evaluateConditional(values, schema, rule as NonBooleanJsfSchema, options, jsonLogicContext)\n      conditionalRules.push(result)\n    })\n\n  // Process the conditional rules\n  for (const { rule, matches } of conditionalRules) {\n    // If the rule matches, process the then branch\n    if (matches && rule.then) {\n      processBranch(schema, values, rule.then, options, jsonLogicContext)\n      // Delete the then branch to avoid processing it again when validating the schema\n      delete rule.then\n    }\n    // If the rule doesn't match, process the else branch\n    else if (!matches && rule.else) {\n      processBranch(schema, values, rule.else, options, jsonLogicContext)\n      // Delete the else branch to avoid processing it again when validating the schema\n      delete rule.else\n    }\n  }\n\n  if (schema.properties) {\n    for (const [key, property] of Object.entries(schema.properties)) {\n      if (typeof property === 'object') {\n        const propertySchema = property as JsfObjectSchema\n        if (propertySchema.type === 'object') {\n          applySchemaRules(propertySchema, values[key] as ObjectValue, options, jsonLogicContext)\n        }\n        if (propertySchema.items) {\n          /*\n          * This is a partial workaround to apply conditional logic to fields with items.\n          * Due to the nature of these fields, the value is an array. applySchemaRules expects\n          * an object and it simply does not process the rules if the value is not an object.\n          *\n          * The correct solution would be to refactor applySchemaRules to handle arrays properly,\n          * but for now we simply pass an empty object to ensure the rules are applied.\n          *\n          * This means that the visibility rules in this case will only be based on the\n          * schema and will not work based on the actual values of the items in the array.\n          *\n          * This is not ideal, but it's better than the previous situation where the rules were not applied at all.\n          */\n          applySchemaRules(propertySchema.items as JsfObjectSchema, {}, options, jsonLogicContext)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Processes a branch of a conditional rule, updating the properties of fields based on the branch's schema\n * @param schema - The JSON schema containing the rules\n * @param values - The current form values\n * @param branch - The branch (schema representing and then/else) to process\n * @param options - Validation options\n * @param jsonLogicContext - JSON Logic context\n */\nfunction processBranch(schema: JsfObjectSchema, values: SchemaValue, branch: JsfSchema, options: LegacyOptions = {}, jsonLogicContext: JsonLogicContext | undefined) {\n  const branchSchema = branch as JsfObjectSchema\n\n  applySchemaRules(branchSchema, values, options, jsonLogicContext)\n  deepMergeSchemas(schema, branchSchema)\n}\n\n/**\n * Updates fields (in place) based on a schema, recursively if needed\n * @param fields - The fields array to mutate\n * @param schema - The schema to use for updating fields\n */\nexport function updateFieldProperties(fields: Field[], schema: JsfObjectSchema, originalSchema: JsfSchema): void {\n  // Get new fields from schema\n  const newFields = buildFieldSchema({\n    schema,\n    name: 'root',\n    required: true,\n    originalSchema,\n    strictInputType: false,\n  })?.fields || []\n\n  // cycle through the original fields and merge the new fields with the original fields\n  for (const field of fields) {\n    const newField = newFields.find(f => f.name === field.name)\n\n    if (newField) {\n      // Properties might have been removed with the most recent schema (due to most recent form values)\n      // so we need to remove them from the original field\n      removeNonExistentProperties(field, newField)\n      deepMergeSchemas(field, newField)\n\n      const fieldSchema = schema.properties?.[field.name]\n      const originalFieldSchema = originalSchema.properties?.[field.name]\n\n      if (fieldSchema && typeof fieldSchema === 'object') {\n        if (field.fields && fieldSchema.type === 'object') {\n          updateFieldProperties(field.fields, fieldSchema as JsfObjectSchema, originalFieldSchema as JsfObjectSchema)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Recursively removes properties that don't exist in newObj\n * @param obj - The object to remove properties from\n * @param newObj - The object to compare with\n */\nfunction removeNonExistentProperties(obj: Field, newObj: Field) {\n  for (const [key] of Object.entries(obj)) {\n    if (!newObj[key]) {\n      delete obj[key]\n    }\n    else if (obj[key] && typeof obj[key] === 'object' && !Array.isArray(obj[key])\n      && newObj[key] && typeof newObj[key] === 'object' && !Array.isArray(newObj[key])) {\n      // Recursively process nested objects\n      removeNonExistentProperties(obj[key] as Field, newObj[key] as Field)\n    }\n  }\n}\n","import type { ValidationError, ValidationErrorPath } from './errors'\nimport type { Field } from './field/type'\nimport type { AsyncOptionsLoader, JsfLayoutConfig, JsfObjectSchema, JsfSchema, ObjectValue, SchemaValue } from './types'\nimport type { LegacyOptions } from './validation/schema'\nimport { getErrorMessage } from './errors/messages'\nimport { buildFieldSchema } from './field/schema'\nimport { calculateFinalSchema, updateFieldProperties } from './mutations'\nimport { addCustomJsonLogicOperations, removeCustomJsonLogicOperations } from './validation/json-logic'\nimport { validateSchema } from './validation/schema'\n\nexport { LegacyOptions } from './validation/schema'\n\ninterface FormResult {\n  fields: Field[]\n  isError: boolean\n  error: string | null\n  handleValidation: (value: SchemaValue) => ValidationResult\n  layout?: JsfLayoutConfig | null\n}\n\n/**\n * Recursive type for form error messages\n * - String for leaf error messages\n * - Nested object for nested fields\n * - Arrays for group-array fields\n */\nexport interface FormErrors {\n  [key: string]: string | FormErrors | Array<null | FormErrors>\n}\n\nexport interface ValidationResult {\n  formErrors?: FormErrors\n}\n\n/**\n * @param path - The path to transform\n * @returns The transformed path\n * Transforms a validation error path in two ways:\n * 1. Removes composition keywords (allOf, anyOf, oneOf) and conditional keywords (then, else)\n * 2. Converts array paths by removing \"items\" keywords but keeping indices\n *\n * Example: ['some_object','allOf', 0, 'then', 'items', 3, 'field'] -> ['some_object', 3, 'field']\n */\nfunction transformErrorPath(path: ValidationErrorPath): Array<string | number> {\n  const result: Array<string | number> = []\n\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i]\n\n    // Skip composition keywords and their indices\n    if (['allOf', 'anyOf', 'oneOf'].includes(segment as string)) {\n      if (i + 1 < path.length && typeof path[i + 1] === 'number') {\n        i++\n      }\n      continue\n    }\n\n    // Skip conditional keywords\n    if (segment === 'then' || segment === 'else') {\n      continue\n    }\n\n    // Skip 'items' but keep the array index that follows\n    if (segment === 'items' && typeof path[i + 1] === 'number') {\n      i++\n      result.push(path[i] as number)\n    }\n    else {\n      result.push(segment as string)\n    }\n  }\n\n  return result\n}\n\n/**\n * @param errors - The validation errors\n * @returns The form errors\n * Transform validation errors into an object with the field names as keys and the error messages as values.\n * For nested fields, creates a nested object structure rather than using dot notation.\n * When multiple errors exist for the same field, the last error message is used.\n *\n * @example\n * Single field error\n * { username: 'Required field' }\n *\n * Nested field error (using nested objects)\n * { address: { street: 'The value must be a string' } }\n *\n * Schema-level error\n * { '': 'The value must match at least one schema' }\n */\nfunction validationErrorsToFormErrors(errors: ValidationErrorWithMessage[]): FormErrors | null {\n  if (errors.length === 0) {\n    return null\n  }\n\n  const result: FormErrors = {}\n\n  for (const error of errors) {\n    const { path } = error\n\n    // Handle schema-level errors (empty path)\n    if (path.length === 0) {\n      result[''] = error.message\n      continue\n    }\n\n    const segments = transformErrorPath(path)\n    let current = result\n\n    for (let i = 0; i < segments.length - 1; i++) {\n      const segment = segments[i]\n\n      if (typeof segment === 'number') {\n        if (!Array.isArray(current)) {\n          throw new TypeError(`Expected an array at path: ${segments.slice(0, i).join('.')}`)\n        }\n\n        if (!current[segment]) {\n          current[segment] = {}\n        }\n\n        current = current[segment] as FormErrors\n      }\n      else {\n        if (typeof segments[i + 1] === 'number') {\n          if (!(segment in current)) {\n            current[segment] = []\n          }\n        }\n        else if (!(segment in current) || typeof current[segment] === 'string') {\n          current[segment] = {}\n        }\n\n        current = current[segment] as FormErrors\n      }\n    }\n\n    if (segments.length > 0) {\n      const lastSegment = segments[segments.length - 1]\n      current[lastSegment] = error.message\n    }\n  }\n\n  return result\n}\n\ninterface ValidationErrorWithMessage extends ValidationError {\n  message: string\n}\n\n/**\n * Add error messages to validation errors (based on the validation type, schema, and value)\n * @param errors - The validation errors\n * @returns The validation errors with error messages added\n */\nfunction addErrorMessages(errors: ValidationError[]): ValidationErrorWithMessage[] {\n  return errors.map((error) => {\n    const { schema, value, validation, customErrorMessage } = error\n\n    return {\n      ...error,\n      message: getErrorMessage(schema, value, validation, customErrorMessage),\n    }\n  })\n}\n\n/**\n * Apply custom error messages from the schema to validation errors\n * @param errors - The validation errors\n * @param schema - The schema that contains custom error messages\n * @returns The validation errors with custom error messages applied\n */\nfunction applyCustomErrorMessages(errors: ValidationErrorWithMessage[], schema: JsfSchema): ValidationErrorWithMessage[] {\n  if (typeof schema !== 'object' || !schema || !errors.length) {\n    return errors\n  }\n\n  return errors.map((error) => {\n    const fieldSchema = error.schema\n    const customErrorMessage = fieldSchema['x-jsf-errorMessage']?.[error.validation]\n    if (\n      fieldSchema\n      && customErrorMessage\n    ) {\n      return {\n        ...error,\n        message: customErrorMessage,\n      }\n    }\n\n    return error\n  })\n}\n\n/**\n * Validate a value against a schema\n * @param value - The value to validate\n * @param schema - The schema to validate against\n * @returns The validation result\n */\nfunction validate(value: SchemaValue, schema: JsfSchema, options: LegacyOptions = {}): ValidationResult {\n  const result: ValidationResult = {}\n  const errors = validateSchema(value, schema, options)\n\n  const errorsWithMessages = addErrorMessages(errors)\n  const processedErrors = applyCustomErrorMessages(errorsWithMessages, schema)\n\n  const formErrors = validationErrorsToFormErrors(processedErrors)\n\n  if (formErrors) {\n    result.formErrors = formErrors\n  }\n\n  return result\n}\n\nexport interface CreateHeadlessFormOptions {\n  /**\n   * The initial values to use for the form\n   */\n  initialValues?: SchemaValue\n  /**\n   * Backward compatibility config with v0\n   */\n  legacyOptions?: LegacyOptions\n  /**\n   * When enabled, ['x-jsf-presentation'].inputType is required for all properties.\n   * @default false\n   */\n  strictInputType?: boolean\n\n  /**\n   * Custom user defined functions. A dictionary of name and function\n   */\n  customJsonLogicOps?: Record<string, (...args: any[]) => any>\n\n  /**\n   * Async option loaders for select fields.\n   * Maps loader IDs (from schema's asyncOptions.id) to loader functions.\n   * \n   * @example\n   * ```ts\n   * {\n   *   'countries-loader': async (context) => {\n   *     const response = await fetch('/api/countries')\n   *     return { options: await response.json() }\n   *   }\n   * }\n   * ```\n   */\n  asyncLoaders?: Record<string, AsyncOptionsLoader>\n}\n\nfunction buildFields(params: {\n  schema: JsfObjectSchema\n  originalSchema: JsfObjectSchema\n  strictInputType?: boolean\n  asyncLoaders?: Record<string, AsyncOptionsLoader>\n  formValues?: ObjectValue\n}): { fields: Field[], layout?: JsfLayoutConfig | null } {\n  const { schema, originalSchema, strictInputType, asyncLoaders, formValues } = params\n  const rootField = buildFieldSchema({\n    schema,\n    name: 'root',\n    required: true,\n    originalSchema,\n    strictInputType,\n    asyncLoaders,\n    formValues,\n  })\n\n  const fields = rootField?.fields || []\n  const layout = rootField?.layout || null\n\n  // If there's layout configuration at the root level, add it to all fields\n  // This allows UI libraries to access the container layout information\n  if (layout && fields.length > 0) {\n    // Add the root layout as a special property to make it accessible\n    fields.forEach((field) => {\n      if (!field._rootLayout) {\n        field._rootLayout = layout\n      }\n    })\n  }\n\n  return { fields, layout }\n}\n\n/**\n * Ensures that no forbidden options are given\n * @param options - The options to validate\n * Alerts to the console that the option is deprecated and not being considered\n */\nfunction validateOptions(options: CreateHeadlessFormOptions) {\n  if (Object.prototype.hasOwnProperty.call(options, 'customProperties')) {\n    console.error('[json-schema-form] `customProperties` is a deprecated option and it\\'s not supported on json-schema-form v1')\n  }\n\n  if (options.customJsonLogicOps) {\n    if (typeof options.customJsonLogicOps !== 'object' || options.customJsonLogicOps === null) {\n      throw new TypeError('validationOptions.customJsonLogicOps must be an object.')\n    }\n\n    for (const [name, func] of Object.entries(options.customJsonLogicOps)) {\n      if (typeof func !== 'function') {\n        throw new TypeError(\n          `Custom JSON Logic operator '${name}' must be a function, but received type '${typeof func}'.`,\n        )\n      }\n    }\n  }\n}\n\nexport function createHeadlessForm(\n  schema: JsfObjectSchema,\n  options: CreateHeadlessFormOptions = {},\n): FormResult {\n  validateOptions(options)\n  const initialValues = options.initialValues || {}\n  const strictInputType = options.strictInputType || false\n  const asyncLoaders = options.asyncLoaders || {}\n  // Make a new version of the schema with all the computed attrs applied, as well as the final version of each property (taking into account conditional rules)\n  const updatedSchema = calculateFinalSchema({\n    schema,\n    values: initialValues,\n    options: options.legacyOptions,\n  })\n\n  const { fields, layout } = buildFields({\n    schema: updatedSchema,\n    originalSchema: schema,\n    strictInputType,\n    asyncLoaders,\n    formValues: initialValues as ObjectValue,\n  })\n\n  // TODO: check if we need this isError variable exposed\n  const isError = false\n\n  const handleValidation = (value: SchemaValue) => {\n    const customJsonLogicOps = options?.customJsonLogicOps\n\n    try {\n      addCustomJsonLogicOperations(customJsonLogicOps)\n\n      const updatedSchema = calculateFinalSchema({\n        schema,\n        values: value,\n        options: options.legacyOptions,\n      })\n\n      const result = validate(value, updatedSchema, options.legacyOptions)\n\n      updateFieldProperties(fields, updatedSchema, schema)\n\n      return result\n    }\n    finally {\n      removeCustomJsonLogicOperations(customJsonLogicOps)\n    }\n  }\n\n  return {\n    fields,\n    isError,\n    error: null,\n    handleValidation,\n    layout,\n  }\n}\n","import type { JsfSchema } from './types'\nimport difference from 'lodash/difference'\nimport get from 'lodash/get'\nimport intersection from 'lodash/intersection'\nimport merge from 'lodash/merge'\nimport mergeWith from 'lodash/mergeWith'\nimport set from 'lodash/set'\n\ntype FieldOutput = Partial<JsfSchema>\n\ntype FieldModification = Partial<JsfSchema> & {\n  /**\n   * @deprecated Use `x-jsf-presentation` instead\n   */\n  presentation?: JsfSchema['x-jsf-presentation']\n  /**\n   * @deprecated Use `x-jsf-errorMessage` instead\n   */\n  errorMessage?: JsfSchema['x-jsf-errorMessage']\n}\n\ninterface ModifyConfig {\n  fields?: Record<string, FieldModification | ((attrs: JsfSchema) => FieldOutput)>\n  allFields?: (name: string, attrs: JsfSchema) => FieldModification\n  create?: Record<string, FieldModification>\n  pick?: string[]\n  orderRoot?: string[] | ((originalOrder: string[]) => string[])\n  muteLogging?: boolean\n};\n\ntype WarningType = 'FIELD_TO_CHANGE_NOT_FOUND'\n  | 'ORDER_MISSING_FIELDS'\n  | 'FIELD_TO_CREATE_EXISTS'\n  | 'PICK_MISSED_FIELD'\n\ninterface Warning {\n  type: WarningType\n  message: string\n  meta?: Record<string, any>\n}\n\ninterface ModifyResult {\n  warnings: Warning[] | null\n}\n\n/**\n * Converts a short path to a full path\n * @param {string} path\n * @returns {string} The full path\n * @example\n * shortToFullPath('foo.bar') // 'foo.properties.bar'\n */\nfunction shortToFullPath(path: string) {\n  return path.replaceAll('.', '.properties.')\n}\n\n/**\n * Standardizes the attributes of a field, using the x-jsf-errorMessage and x-jsf-presentation shorthands\n * @param {JsfSchema} attrs - The attributes of a field\n * @returns {JsfSchema} The standardized attributes\n */\nfunction standardizeAttrs(attrs: FieldModification) {\n  const { errorMessage, presentation, properties, ...rest } = attrs as Record<string, unknown>\n\n  return {\n    ...rest,\n    ...(presentation ? { 'x-jsf-presentation': presentation } : {}),\n    ...(errorMessage ? { 'x-jsf-errorMessage': errorMessage } : {}),\n  } as JsfSchema\n}\n\n/**\n * Customizer function for the mergeWith function\n * @param _ - The target array\n * @param newVal - The array to merge\n * @returns The target array\n */\nfunction mergeReplaceArray(_: any, newVal: any) {\n  return Array.isArray(newVal) ? newVal : undefined\n}\n\n/**\n *  Checks if a conditional schema references any of the fields being picked\n * @param {JsfSchema} condition - The conditional schema\n * @param {string[]} fieldsToPick - The fields being picked\n * @returns {boolean} True if the conditional schema references any of the fields being picked\n */\nfunction isConditionalReferencingAnyPickedField(condition: JsfSchema, fieldsToPick: string[]): boolean {\n  const { if: ifCondition, then: thenCondition, else: elseCondition } = condition\n\n  const inIf = intersection(ifCondition?.required || [], fieldsToPick)\n\n  if (inIf.length > 0) {\n    return true\n  }\n\n  const inThen\n    = intersection(thenCondition?.required || [], fieldsToPick)\n      || intersection(Object.keys(thenCondition?.properties || {}), fieldsToPick)\n\n  if (inThen.length > 0) {\n    return true\n  }\n\n  const inElse\n    = intersection(elseCondition?.required || [], fieldsToPick)\n      || intersection(Object.keys(elseCondition?.properties || {}), fieldsToPick)\n\n  if (inElse.length > 0) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Rewrites fields in the schema\n * @param {JsfSchema} schema - The schema to rewrite\n * @param {ModifyConfig['fields']} fieldsConfig - The fields to rewrite\n * @returns {ModifyResult} The warnings that occurred during the rewrite\n */\nfunction rewriteFields(schema: JsfSchema, fieldsConfig: ModifyConfig['fields']): ModifyResult {\n  if (!fieldsConfig) {\n    return { warnings: null }\n  }\n\n  const warnings: Warning[] = []\n\n  const fieldsToModify = Object.entries(fieldsConfig)\n\n  fieldsToModify.forEach(([shortPath, mutation]) => {\n    const fieldPath = shortToFullPath(shortPath)\n\n    const fieldAttrs = get(schema.properties, fieldPath) as JsfSchema\n\n    if (!fieldAttrs) {\n      // Do not override/edit a field that does not exist.\n      // That's the job of config.create() method.\n      warnings.push({\n        type: 'FIELD_TO_CHANGE_NOT_FOUND',\n        message: `Changing field \"${shortPath}\" was ignored because it does not exist.`,\n      })\n      return\n    }\n\n    const fieldChanges = typeof mutation === 'function' ? mutation(fieldAttrs) : mutation\n\n    mergeWith(\n      fieldAttrs,\n      {\n        ...standardizeAttrs(fieldChanges) as object,\n      },\n      mergeReplaceArray,\n    )\n\n    if (fieldChanges.properties) {\n      const result = rewriteFields(get(schema.properties!, fieldPath), fieldChanges.properties as ModifyConfig['fields'])\n      if (result.warnings) {\n        warnings.push(...result.warnings)\n      }\n    }\n  })\n\n  return { warnings: warnings.flat() }\n}\n\nfunction rewriteAllFields(schema: JsfSchema, configCallback: ModifyConfig['allFields'], context?: { parent: string }) {\n  if (!configCallback || typeof schema !== 'object' || schema === null) {\n    return { warnings: null }\n  }\n\n  const parentName = context?.parent\n\n  if (typeof schema === 'object' && schema.properties) {\n    Object.entries(schema.properties).forEach(([fieldName, fieldAttrs]) => {\n      const fullName = parentName ? `${parentName}.${fieldName}` : fieldName\n      const callbackResult = configCallback(fullName, fieldAttrs)\n      const resultWithStandardizedAttrs = standardizeAttrs(callbackResult)\n\n      mergeWith(\n        get(schema.properties, fieldName),\n        {\n          ...(fieldAttrs as object),\n          ...(resultWithStandardizedAttrs as object),\n        },\n        mergeReplaceArray,\n      )\n\n      // Nested fields, go recursive (fieldset)\n      if (fieldAttrs.properties) {\n        rewriteAllFields(fieldAttrs, configCallback, {\n          parent: fieldName,\n        })\n      }\n    })\n  }\n\n  return { warnings: null }\n}\n\n/**\n * Reorders fields in the schema in-place\n * @param {JsfSchema} schema - The schema to reorder\n * @param {ModifyConfig['orderRoot']} configOrder - The order to reorder the fields\n * @returns {ModifyResult} The warnings that occurred during the reordering\n */\nfunction reorderFields(schema: JsfSchema, configOrder: ModifyConfig['orderRoot']) {\n  if (!configOrder) {\n    return { warnings: null }\n  }\n\n  const warnings: Warning[] = []\n  const originalOrder = schema['x-jsf-order'] || []\n  const orderConfig = typeof configOrder === 'function' ? configOrder(originalOrder) : configOrder\n  const remaining = difference(originalOrder, orderConfig)\n\n  if (remaining.length > 0) {\n    warnings.push({\n      type: 'ORDER_MISSING_FIELDS',\n      message: `Some fields got forgotten in the new order. They were automatically appended: ${remaining.join(\n        ', ',\n      )}`,\n    })\n  }\n  schema['x-jsf-order'] = [...orderConfig, ...remaining]\n\n  return { warnings }\n}\n\n/**\n * Creates fields in the schema in-place\n * @param {JsfSchema} schema - The schema to create fields in\n * @param {ModifyConfig['create']} fieldsConfig - The fields to create\n * @returns {ModifyResult} The warnings that occurred during the creation\n */\nfunction createFields(schema: JsfSchema, fieldsConfig: ModifyConfig['create']) {\n  if (!fieldsConfig) {\n    return { warnings: null }\n  }\n\n  const warnings: Warning[] = []\n  const fieldsToCreate = Object.entries(fieldsConfig)\n\n  fieldsToCreate.forEach(([shortPath, fieldAttrs]) => {\n    const fieldPath = shortToFullPath(shortPath)\n    if (!fieldAttrs) {\n      return { warnings: null }\n    }\n\n    if (fieldAttrs.properties) {\n      // Recursive to nested fields...\n      const recursiveFieldAttrs = get(schema.properties, fieldPath)\n      if (!recursiveFieldAttrs) {\n        return { warnings: null }\n      }\n      const result = createFields(recursiveFieldAttrs, fieldAttrs.properties as ModifyConfig['create'])\n      if (result.warnings) {\n        warnings.push(...result.warnings)\n      }\n    }\n\n    const fieldInSchema = get(schema.properties, fieldPath)\n\n    if (fieldInSchema) {\n      warnings.push({\n        type: 'FIELD_TO_CREATE_EXISTS',\n        message: `Creating field \"${shortPath}\" was ignored because it already exists.`,\n      })\n      return\n    }\n\n    const fieldInObjectPath = set({}, fieldPath, (fieldAttrs))\n    merge(schema.properties, fieldInObjectPath)\n  })\n\n  return { warnings: warnings.flat() }\n}\n\n/**\n * Returns a new schema with only the picked fields\n *\n * @param {JsfSchema} originalSchema - The original schema\n * @param {ModifyConfig['pick']} fieldsToPick - The fields to pick\n * @returns {ModifyResult} The new schema and the warnings that occurred during the picking\n */\nfunction pickFields(originalSchema: JsfSchema, fieldsToPick: ModifyConfig['pick']): { schema: JsfSchema } & ModifyResult {\n  if (!fieldsToPick) {\n    return { schema: originalSchema, warnings: null }\n  }\n\n  // Start a new schema without any properties\n  const newSchema: JsfSchema = {\n    properties: {},\n  }\n\n  Object.entries(originalSchema).forEach(([attrKey, attrValue]) => {\n    switch (attrKey) {\n      case 'properties':\n        // TODO  handle recursive nested fields\n        fieldsToPick.forEach((fieldPath) => {\n          set(newSchema.properties!, fieldPath, attrValue[fieldPath])\n        })\n        break\n      case 'x-jsf-order':\n      case 'required':\n        newSchema[attrKey] = attrValue.filter((fieldName: string) => fieldsToPick.includes(fieldName))\n        break\n      case 'allOf': {\n        // remove conditionals that do not contain any reference to fieldsToPick\n        const newConditionalArray = originalSchema[attrKey]?.filter((condition: JsfSchema) =>\n          isConditionalReferencingAnyPickedField(condition, fieldsToPick),\n        )\n\n        newSchema[attrKey] = newConditionalArray\n\n        break\n      }\n      case 'x-jsf-logic':\n        newSchema[attrKey] = attrValue\n        break\n    }\n  })\n\n  // TODO: Improve this, as this logic could be done in the isConditionalReferencingAnyPickedField function\n  // Look for unpicked fields in the conditionals\n  let missingFields: Record<string, { path: string }> = {}\n  if (newSchema.allOf?.length) {\n    newSchema.allOf.forEach((condition: JsfSchema) => {\n      const { if: ifCondition, then: thenCondition, else: elseCondition } = condition\n      const index = originalSchema.allOf?.indexOf(condition)\n      missingFields = {\n        ...missingFields,\n        ...findMissingFields(ifCondition, {\n          fields: fieldsToPick,\n          path: `allOf[${index}].if`,\n        }),\n        ...findMissingFields(thenCondition, {\n          fields: fieldsToPick,\n          path: `allOf[${index}].then`,\n        }),\n        ...findMissingFields(elseCondition, {\n          fields: fieldsToPick,\n          path: `allOf[${index}].else`,\n        }),\n      }\n    })\n  }\n\n  const warnings: Warning[] = []\n\n  if (Object.keys(missingFields).length > 0) {\n    // Re-add them to the schema...\n    Object.entries(missingFields).forEach(([fieldName]) => {\n      set(newSchema.properties!, fieldName, originalSchema.properties?.[fieldName])\n    })\n\n    warnings.push({\n      type: 'PICK_MISSED_FIELD',\n      message: `The picked fields are in conditionals that refeer other fields. They added automatically: ${Object.keys(\n        missingFields,\n      )\n        .map(name => `\"${name}\"`)\n        .join(', ')}. Check \"meta\" for more details.`,\n      meta: missingFields,\n    })\n  }\n\n  return { schema: newSchema, warnings }\n}\n\n/**\n * Finds missing fields in a conditional\n * @param {JsfSchema} conditional - The conditional schema\n * @param {object} params - The parameters\n * @param {string[]} params.fields - The fields to pick\n * @param {string} params.path - The path to the conditional\n * @returns {Record<string, { path: string }>} The missing fields\n */\nfunction findMissingFields(conditional: JsfSchema | undefined, { fields, path }: { fields: string[], path: string }) {\n  if (!conditional) {\n    return null\n  }\n\n  const missingFields: Record<string, { path: string }> = {}\n\n  conditional.required?.forEach((fieldName: string) => {\n    if (!fields.includes(fieldName)) {\n      missingFields[fieldName] = {\n        path,\n      }\n    }\n  })\n\n  Object.entries(conditional.properties || []).forEach(([fieldName]) => {\n    if (!fields.includes(fieldName)) {\n      missingFields[fieldName] = { path }\n    }\n\n    // TODO support nested fields (eg if properties.address.properties.door_number)\n  })\n\n  return missingFields\n}\n\n/**\n * Modifies the schema\n * Use modify() when you need to customize the generated fields. This function creates a new version of JSON schema based on a provided configuration. Then you pass the new schema to createHeadlessForm()\n *\n * @example\n * const modifiedSchema = modify(schema, {\n *   fields: {\n *     name: { type: 'string', title: 'Name' },\n *   },\n * })\n * @param {JsfSchema} originalSchema - The original schema\n * @param {ModifyConfig} config - The config\n * @returns {ModifyResult} The new schema and the warnings that occurred during the modifications\n */\nexport function modifySchema(originalSchema: JsfSchema, config: ModifyConfig) {\n  // Create a deep copy of the original schema so we don't mutate the original one.\n  const schema = JSON.parse(JSON.stringify(originalSchema))\n\n  const resultRewrite = rewriteFields(schema, config.fields)\n  const resultRewriteAll = rewriteAllFields(schema, config.allFields)\n\n  const resultCreate = createFields(schema, config.create)\n\n  const resultPick = pickFields(schema, config.pick)\n\n  const finalSchema = resultPick.schema\n  const resultReorder = reorderFields(finalSchema, config.orderRoot)\n\n  if (!config.muteLogging) {\n    console.warn(\n      'json-schema-form modify(): We highly recommend you to handle/report the returned `warnings` as they highlight possible bugs in your modifications. To mute this log, pass `muteLogging: true` to the config.',\n    )\n  }\n\n  const warnings = [\n    resultRewrite.warnings,\n    resultRewriteAll.warnings,\n    resultCreate.warnings,\n    resultPick.warnings,\n    resultReorder.warnings,\n  ]\n    .flat()\n    .filter(Boolean)\n\n  return {\n    schema: finalSchema,\n    warnings,\n  }\n}\n","import type { Field } from '../field/type'\nimport type { JsfLayoutConfig, ResponsiveFieldConfig } from '../types'\n/**\n * Default layout configuration values\n */\nexport const DEFAULT_LAYOUT_CONFIG: Required<Pick<JsfLayoutConfig, 'type' | 'columns' | 'gap'>> = {\n  type: 'columns',\n  columns: 1,\n  gap: '16px',\n}\n\n/**\n * Validates a layout configuration object\n * @param layout - The layout configuration to validate\n * @returns Whether the layout configuration is valid\n */\nexport function isValidLayoutConfig(layout: any): layout is JsfLayoutConfig {\n  if (!layout || typeof layout !== 'object') {\n    return false\n  }\n\n  // Validate type\n  if (layout.type && layout.type !== 'columns') {\n    return false\n  }\n\n  // Validate columns\n  if (layout.columns !== undefined && (!Number.isInteger(layout.columns) || layout.columns < 1)) {\n    return false\n  }\n\n  // Validate gap\n  if (layout.gap && typeof layout.gap !== 'string') {\n    return false\n  }\n\n  // Validate responsive config\n  if (layout.responsive) {\n    const responsiveKeys = ['sm', 'md', 'lg', 'xl']\n    for (const key of responsiveKeys) {\n      const value = layout.responsive[key]\n      if (value !== undefined && (!Number.isInteger(value) || value < 1)) {\n        return false\n      }\n    }\n  }\n\n  // Validate col span/start/end (can be number or responsive object)\n  const colProps = ['colSpan', 'colStart', 'colEnd'] as const\n  for (const prop of colProps) {\n    const value = layout[prop]\n    if (value !== undefined) {\n      if (typeof value === 'number') {\n        if (!Number.isInteger(value) || value < 1) {\n          return false\n        }\n      }\n      else if (typeof value === 'object' && value !== null) {\n        // Validate responsive object\n        const responsiveKeys = ['sm', 'md', 'lg', 'xl'] as const\n        for (const key of responsiveKeys) {\n          const responsiveValue = value[key]\n          if (responsiveValue !== undefined && (!Number.isInteger(responsiveValue) || responsiveValue < 1)) {\n            return false\n          }\n        }\n      }\n      else {\n        return false\n      }\n    }\n  }\n\n  return true\n}\n\n/**\n * Normalizes a layout configuration by merging with defaults\n * @param layout - The layout configuration to normalize\n * @returns Normalized layout configuration\n */\nexport function normalizeLayoutConfig(layout?: JsfLayoutConfig): JsfLayoutConfig {\n  if (!layout || !isValidLayoutConfig(layout)) {\n    return DEFAULT_LAYOUT_CONFIG\n  }\n\n  return {\n    ...DEFAULT_LAYOUT_CONFIG,\n    ...layout,\n  }\n}\n\n/**\n * Extracts layout information from a field for easier consumption by UI libraries\n * @param field - The field to extract layout from\n * @returns Layout information or null if no layout is configured\n */\nexport function getFieldLayoutInfo(field: Field): JsfLayoutConfig | null {\n  return field.layout || null\n}\n\n/**\n * Extracts root container layout information from any field in a form\n * @param field - Any field from the form\n * @returns Root container layout information or null if no layout is configured\n */\nexport function getRootLayoutInfo(field: Field): JsfLayoutConfig | null {\n  return field._rootLayout || null\n}\n\n/**\n * Gets the effective layout for a form container by checking the first field's root layout\n * @param fields - Array of fields from createHeadlessForm\n * @returns Container layout information or null\n */\nexport function getFormContainerLayout(fields: Field[]): JsfLayoutConfig | null {\n  if (!fields.length) {\n    return null\n  }\n  return getRootLayoutInfo(fields[0])\n}\n\n/**\n * Generates CSS Grid style properties from layout configuration\n * @param layout - The layout configuration\n * @returns CSS properties object for CSS Grid\n */\nexport function generateCSSGridProperties(layout: JsfLayoutConfig): Record<string, string> {\n  const normalized = normalizeLayoutConfig(layout)\n  const properties: Record<string, string> = {}\n\n  // Basic grid setup\n  if (normalized.type === 'columns') {\n    properties.display = 'grid'\n    properties.gridTemplateColumns = `repeat(${normalized.columns}, 1fr)`\n\n    if (normalized.gap) {\n      properties.gap = normalized.gap\n    }\n  }\n\n  // Individual field properties\n  if (layout.colSpan) {\n    if (typeof layout.colSpan === 'number') {\n      properties.gridColumn = `span ${layout.colSpan}`\n    }\n    else {\n      // For responsive colSpan, use the largest value as default\n      const values = Object.values(layout.colSpan).filter(v => typeof v === 'number') as number[]\n      if (values.length > 0) {\n        const maxValue = Math.max(...values)\n        properties.gridColumn = `span ${maxValue}`\n      }\n    }\n  }\n\n  // Handle colStart/colEnd (simplified for now - can be extended for responsive)\n  const colStart = typeof layout.colStart === 'number' ? layout.colStart : undefined\n  const colEnd = typeof layout.colEnd === 'number' ? layout.colEnd : undefined\n\n  if (colStart && colEnd) {\n    properties.gridColumn = `${colStart} / ${colEnd}`\n  }\n  else if (colStart) {\n    properties.gridColumnStart = `${colStart}`\n  }\n  else if (colEnd) {\n    properties.gridColumnEnd = `${colEnd}`\n  }\n\n  return properties\n}\n\n/**\n * Generates responsive CSS media queries for layout\n * @param layout - The layout configuration with responsive settings\n * @param breakpoints - Custom breakpoints (optional)\n * @returns CSS media query string\n */\nexport function generateResponsiveCSS(\n  layout: JsfLayoutConfig,\n  breakpoints = {\n    sm: '640px',\n    md: '768px',\n    lg: '1024px',\n    xl: '1280px',\n  },\n): string {\n  if (!layout.responsive) {\n    return ''\n  }\n\n  const mediaQueries: string[] = []\n\n  Object.entries(layout.responsive).forEach(([breakpoint, columns]) => {\n    if (columns && breakpoints[breakpoint as keyof typeof breakpoints]) {\n      const minWidth = breakpoints[breakpoint as keyof typeof breakpoints]\n      mediaQueries.push(`@media (min-width: ${minWidth}) { grid-template-columns: repeat(${columns}, 1fr); }`)\n    }\n  })\n\n  return mediaQueries.join('\\n')\n}\n\n/**\n * Generates responsive CSS media queries for individual field properties\n * @param layout - The field layout configuration with responsive settings\n * @param breakpoints - Custom breakpoints (optional)\n * @returns CSS media query string for individual fields\n */\nexport function generateResponsiveFieldCSS(\n  layout: JsfLayoutConfig,\n  breakpoints = {\n    sm: '640px',\n    md: '768px',\n    lg: '1024px',\n    xl: '1280px',\n  },\n): string {\n  const mediaQueries: string[] = []\n\n  // Handle responsive colSpan\n  if (layout.colSpan && typeof layout.colSpan === 'object') {\n    Object.entries(layout.colSpan).forEach(([breakpoint, span]) => {\n      if (span && breakpoints[breakpoint as keyof typeof breakpoints]) {\n        const minWidth = breakpoints[breakpoint as keyof typeof breakpoints]\n        mediaQueries.push(`@media (min-width: ${minWidth}) { grid-column: span ${span}; }`)\n      }\n    })\n  }\n\n  // Handle responsive colStart\n  if (layout.colStart && typeof layout.colStart === 'object') {\n    Object.entries(layout.colStart).forEach(([breakpoint, start]) => {\n      if (start && breakpoints[breakpoint as keyof typeof breakpoints]) {\n        const minWidth = breakpoints[breakpoint as keyof typeof breakpoints]\n        mediaQueries.push(`@media (min-width: ${minWidth}) { grid-column-start: ${start}; }`)\n      }\n    })\n  }\n\n  // Handle responsive colEnd\n  if (layout.colEnd && typeof layout.colEnd === 'object') {\n    Object.entries(layout.colEnd).forEach(([breakpoint, end]) => {\n      if (end && breakpoints[breakpoint as keyof typeof breakpoints]) {\n        const minWidth = breakpoints[breakpoint as keyof typeof breakpoints]\n        mediaQueries.push(`@media (min-width: ${minWidth}) { grid-column-end: ${end}; }`)\n      }\n    })\n  }\n\n  return mediaQueries.join('\\n')\n}\n\n/**\n * Utility function to get the base (non-responsive) value from a field property\n * @param value - The field property value (can be number or responsive object)\n * @returns The base value or undefined\n */\nexport function getBaseFieldValue(value: number | ResponsiveFieldConfig | undefined): number | undefined {\n  if (typeof value === 'number') {\n    return value\n  }\n  if (typeof value === 'object' && value !== null) {\n    // Return the largest value as base, or the last defined value\n    const values = Object.values(value).filter(v => typeof v === 'number') as number[]\n    return values.length > 0 ? Math.max(...values) : undefined\n  }\n  return undefined\n}\n"],"mappings":"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","names":["require_types","__commonJSMin","exports","module","require_sets","__commonJSMin","exports","types","INTS","WORDS","WHITESPACE","NOTANYCHAR","require_util","__commonJSMin","exports","types","sets","CTRL","SLSH","str","chars_regex","s","b","lbs","a16","b16","c8","dctrl","eslsh","code","c","regexpStr","tokens","regexp","rs","msg","require_positions","__commonJSMin","exports","types","require_lib","__commonJSMin","exports","module","util","types","sets","positions","regexpStr","i","l","c","start","lastGroup","last","groupStack","repeatErr","str","not","classTokens","group","stack","rs","min","max","require_lib","__commonJSMin","exports","module","SubRange","_SubRange","low","high","range","DRange","_DRange","a","b","previous","_add","subrange","i","newRanges","_subtract","_intersect","index","result","require_randexp","__commonJSMin","exports","module","ret","DRange","types","RandExp","regexp","m","token","groups","stack","str","n","i","l","expandedSet","code","arr","drange","subrange","j","otherCaseCode","a","b","range","randexp","require_cjs","__commonJSMin","exports","module","isMergeableObject","value","isNonNullObject","isSpecial","stringValue","isReactElement","canUseSymbol","REACT_ELEMENT_TYPE","emptyTarget","val","cloneUnlessOtherwiseSpecified","options","deepmerge","defaultArrayMerge","target","source","element","getMergeFunction","key","customMerge","getEnumerableOwnPropertySymbols","symbol","getKeys","propertyIsOnObject","object","property","propertyIsUnsafe","mergeObject","destination","sourceIsArray","targetIsArray","sourceAndTargetTypesMatch","array","prev","next","deepmerge_1","require_freeGlobal","__commonJSMin","exports","module","freeGlobal","require_root","__commonJSMin","exports","module","freeGlobal","freeSelf","root","require_Symbol","__commonJSMin","exports","module","root","Symbol","require_getRawTag","__commonJSMin","exports","module","Symbol","objectProto","hasOwnProperty","nativeObjectToString","symToStringTag","getRawTag","value","isOwn","tag","unmasked","result","require_objectToString","__commonJSMin","exports","module","objectProto","nativeObjectToString","objectToString","value","require_baseGetTag","__commonJSMin","exports","module","Symbol","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","baseGetTag","value","require_isObject","__commonJSMin","exports","module","isObject","value","type","require_isFunction","__commonJSMin","exports","module","baseGetTag","isObject","asyncTag","funcTag","genTag","proxyTag","isFunction","value","tag","require_coreJsData","__commonJSMin","exports","module","root","coreJsData","require_isMasked","__commonJSMin","exports","module","coreJsData","maskSrcKey","uid","isMasked","func","require_toSource","__commonJSMin","exports","module","funcProto","funcToString","toSource","func","require_baseIsNative","__commonJSMin","exports","module","isFunction","isMasked","isObject","toSource","reRegExpChar","reIsHostCtor","funcProto","objectProto","funcToString","hasOwnProperty","reIsNative","baseIsNative","value","pattern","require_getValue","__commonJSMin","exports","module","getValue","object","key","require_getNative","__commonJSMin","exports","module","baseIsNative","getValue","getNative","object","key","value","require_nativeCreate","__commonJSMin","exports","module","getNative","nativeCreate","require_hashClear","__commonJSMin","exports","module","nativeCreate","hashClear","require_hashDelete","__commonJSMin","exports","module","hashDelete","key","result","require_hashGet","__commonJSMin","exports","module","nativeCreate","HASH_UNDEFINED","objectProto","hasOwnProperty","hashGet","key","data","result","require_hashHas","__commonJSMin","exports","module","nativeCreate","objectProto","hasOwnProperty","hashHas","key","data","require_hashSet","__commonJSMin","exports","module","nativeCreate","HASH_UNDEFINED","hashSet","key","value","data","require_Hash","__commonJSMin","exports","module","hashClear","hashDelete","hashGet","hashHas","hashSet","Hash","entries","index","length","entry","require_listCacheClear","__commonJSMin","exports","module","listCacheClear","require_eq","__commonJSMin","exports","module","eq","value","other","require_assocIndexOf","__commonJSMin","exports","module","eq","assocIndexOf","array","key","length","require_listCacheDelete","__commonJSMin","exports","module","assocIndexOf","arrayProto","splice","listCacheDelete","key","data","index","lastIndex","require_listCacheGet","__commonJSMin","exports","module","assocIndexOf","listCacheGet","key","data","index","require_listCacheHas","__commonJSMin","exports","module","assocIndexOf","listCacheHas","key","require_listCacheSet","__commonJSMin","exports","module","assocIndexOf","listCacheSet","key","value","data","index","require_ListCache","__commonJSMin","exports","module","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","ListCache","entries","index","length","entry","require_Map","__commonJSMin","exports","module","getNative","root","Map","require_mapCacheClear","__commonJSMin","exports","module","Hash","ListCache","Map","mapCacheClear","require_isKeyable","__commonJSMin","exports","module","isKeyable","value","type","require_getMapData","__commonJSMin","exports","module","isKeyable","getMapData","map","key","data","require_mapCacheDelete","__commonJSMin","exports","module","getMapData","mapCacheDelete","key","result","require_mapCacheGet","__commonJSMin","exports","module","getMapData","mapCacheGet","key","require_mapCacheHas","__commonJSMin","exports","module","getMapData","mapCacheHas","key","require_mapCacheSet","__commonJSMin","exports","module","getMapData","mapCacheSet","key","value","data","size","require_MapCache","__commonJSMin","exports","module","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","entries","index","length","entry","require_setCacheAdd","__commonJSMin","exports","module","HASH_UNDEFINED","setCacheAdd","value","require_setCacheHas","__commonJSMin","exports","module","setCacheHas","value","require_SetCache","__commonJSMin","exports","module","MapCache","setCacheAdd","setCacheHas","SetCache","values","index","length","require_baseFindIndex","__commonJSMin","exports","module","baseFindIndex","array","predicate","fromIndex","fromRight","length","index","require_baseIsNaN","__commonJSMin","exports","module","baseIsNaN","value","require_strictIndexOf","__commonJSMin","exports","module","strictIndexOf","array","value","fromIndex","index","length","require_baseIndexOf","__commonJSMin","exports","module","baseFindIndex","baseIsNaN","strictIndexOf","baseIndexOf","array","value","fromIndex","require_arrayIncludes","__commonJSMin","exports","module","baseIndexOf","arrayIncludes","array","value","length","require_arrayIncludesWith","__commonJSMin","exports","module","arrayIncludesWith","array","value","comparator","index","length","require_arrayMap","__commonJSMin","exports","module","arrayMap","array","iteratee","index","length","result","require_baseUnary","__commonJSMin","exports","module","baseUnary","func","value","require_cacheHas","__commonJSMin","exports","module","cacheHas","cache","key","require_baseDifference","__commonJSMin","exports","module","SetCache","arrayIncludes","arrayIncludesWith","arrayMap","baseUnary","cacheHas","LARGE_ARRAY_SIZE","baseDifference","array","values","iteratee","comparator","index","includes","isCommon","length","result","valuesLength","outer","value","computed","valuesIndex","require_arrayPush","__commonJSMin","exports","module","arrayPush","array","values","index","length","offset","require_isObjectLike","__commonJSMin","exports","module","isObjectLike","value","require_baseIsArguments","__commonJSMin","exports","module","baseGetTag","isObjectLike","argsTag","baseIsArguments","value","require_isArguments","__commonJSMin","exports","module","baseIsArguments","isObjectLike","objectProto","hasOwnProperty","propertyIsEnumerable","isArguments","value","require_isArray","__commonJSMin","exports","module","isArray","require_isFlattenable","__commonJSMin","exports","module","Symbol","isArguments","isArray","spreadableSymbol","isFlattenable","value","require_baseFlatten","__commonJSMin","exports","module","arrayPush","isFlattenable","baseFlatten","array","depth","predicate","isStrict","result","index","length","value","require_identity","__commonJSMin","exports","module","identity","value","require_apply","__commonJSMin","exports","module","apply","func","thisArg","args","require_overRest","__commonJSMin","exports","module","apply","nativeMax","overRest","func","start","transform","args","index","length","array","otherArgs","require_constant","__commonJSMin","exports","module","constant","value","require_defineProperty","__commonJSMin","exports","module","getNative","defineProperty","func","require_baseSetToString","__commonJSMin","exports","module","constant","defineProperty","identity","baseSetToString","func","string","require_shortOut","__commonJSMin","exports","module","HOT_COUNT","HOT_SPAN","nativeNow","shortOut","func","count","lastCalled","stamp","remaining","require_setToString","__commonJSMin","exports","module","baseSetToString","shortOut","setToString","require_baseRest","__commonJSMin","exports","module","identity","overRest","setToString","baseRest","func","start","require_isLength","__commonJSMin","exports","module","MAX_SAFE_INTEGER","isLength","value","require_isArrayLike","__commonJSMin","exports","module","isFunction","isLength","isArrayLike","value","require_isArrayLikeObject","__commonJSMin","exports","module","isArrayLike","isObjectLike","isArrayLikeObject","value","require_difference","__commonJSMin","exports","module","baseDifference","baseFlatten","baseRest","isArrayLikeObject","difference","array","values","require_isSymbol","__commonJSMin","exports","module","baseGetTag","isObjectLike","symbolTag","isSymbol","value","require_isKey","__commonJSMin","exports","module","isArray","isSymbol","reIsDeepProp","reIsPlainProp","isKey","value","object","type","require_memoize","__commonJSMin","exports","module","MapCache","FUNC_ERROR_TEXT","memoize","func","resolver","memoized","args","key","cache","result","require_memoizeCapped","__commonJSMin","exports","module","memoize","MAX_MEMOIZE_SIZE","memoizeCapped","func","result","key","cache","require_stringToPath","__commonJSMin","exports","module","memoizeCapped","rePropName","reEscapeChar","stringToPath","string","result","match","number","quote","subString","require_baseToString","__commonJSMin","exports","module","Symbol","arrayMap","isArray","isSymbol","INFINITY","symbolProto","symbolToString","baseToString","value","result","require_toString","__commonJSMin","exports","module","baseToString","toString","value","require_castPath","__commonJSMin","exports","module","isArray","isKey","stringToPath","toString","castPath","value","object","require_toKey","__commonJSMin","exports","module","isSymbol","INFINITY","toKey","value","result","require_baseGet","__commonJSMin","exports","module","castPath","toKey","baseGet","object","path","index","length","require_get","__commonJSMin","exports","module","baseGet","get","object","path","defaultValue","result","require_baseIntersection","__commonJSMin","exports","module","SetCache","arrayIncludes","arrayIncludesWith","arrayMap","baseUnary","cacheHas","nativeMin","baseIntersection","arrays","iteratee","comparator","includes","length","othLength","othIndex","caches","maxLength","result","array","index","seen","outer","value","computed","cache","require_castArrayLikeObject","__commonJSMin","exports","module","isArrayLikeObject","castArrayLikeObject","value","require_intersection","__commonJSMin","exports","module","arrayMap","baseIntersection","baseRest","castArrayLikeObject","intersection","arrays","mapped","require_stackClear","__commonJSMin","exports","module","ListCache","stackClear","require_stackDelete","__commonJSMin","exports","module","stackDelete","key","data","result","require_stackGet","__commonJSMin","exports","module","stackGet","key","require_stackHas","__commonJSMin","exports","module","stackHas","key","require_stackSet","__commonJSMin","exports","module","ListCache","Map","MapCache","LARGE_ARRAY_SIZE","stackSet","key","value","data","pairs","require_Stack","__commonJSMin","exports","module","ListCache","stackClear","stackDelete","stackGet","stackHas","stackSet","Stack","entries","data","require_baseAssignValue","__commonJSMin","exports","module","defineProperty","baseAssignValue","object","key","value","require_assignMergeValue","__commonJSMin","exports","module","baseAssignValue","eq","assignMergeValue","object","key","value","require_createBaseFor","__commonJSMin","exports","module","createBaseFor","fromRight","object","iteratee","keysFunc","index","iterable","props","length","key","require_baseFor","__commonJSMin","exports","module","createBaseFor","baseFor","require_cloneBuffer","__commonJSMin","exports","module","root","freeExports","freeModule","moduleExports","Buffer","allocUnsafe","cloneBuffer","buffer","isDeep","length","result","require_Uint8Array","__commonJSMin","exports","module","root","Uint8Array","require_cloneArrayBuffer","__commonJSMin","exports","module","Uint8Array","cloneArrayBuffer","arrayBuffer","result","require_cloneTypedArray","__commonJSMin","exports","module","cloneArrayBuffer","cloneTypedArray","typedArray","isDeep","buffer","require_copyArray","__commonJSMin","exports","module","copyArray","source","array","index","length","require_baseCreate","__commonJSMin","exports","module","isObject","objectCreate","baseCreate","object","proto","result","require_overArg","__commonJSMin","exports","module","overArg","func","transform","arg","require_getPrototype","__commonJSMin","exports","module","overArg","getPrototype","require_isPrototype","__commonJSMin","exports","module","objectProto","isPrototype","value","Ctor","proto","require_initCloneObject","__commonJSMin","exports","module","baseCreate","getPrototype","isPrototype","initCloneObject","object","require_stubFalse","__commonJSMin","exports","module","stubFalse","require_isBuffer","__commonJSMin","exports","module","root","stubFalse","freeExports","freeModule","moduleExports","Buffer","nativeIsBuffer","isBuffer","require_isPlainObject","__commonJSMin","exports","module","baseGetTag","getPrototype","isObjectLike","objectTag","funcProto","objectProto","funcToString","hasOwnProperty","objectCtorString","isPlainObject","value","proto","Ctor","require_baseIsTypedArray","__commonJSMin","exports","module","baseGetTag","isLength","isObjectLike","argsTag","arrayTag","boolTag","dateTag","errorTag","funcTag","mapTag","numberTag","objectTag","regexpTag","setTag","stringTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","typedArrayTags","baseIsTypedArray","value","require_nodeUtil","__commonJSMin","exports","module","freeGlobal","freeExports","freeModule","moduleExports","freeProcess","nodeUtil","types","require_isTypedArray","__commonJSMin","exports","module","baseIsTypedArray","baseUnary","nodeUtil","nodeIsTypedArray","isTypedArray","require_safeGet","__commonJSMin","exports","module","safeGet","object","key","require_assignValue","__commonJSMin","exports","module","baseAssignValue","eq","objectProto","hasOwnProperty","assignValue","object","key","value","objValue","require_copyObject","__commonJSMin","exports","module","assignValue","baseAssignValue","copyObject","source","props","object","customizer","isNew","index","length","key","newValue","require_baseTimes","__commonJSMin","exports","module","baseTimes","n","iteratee","index","result","require_isIndex","__commonJSMin","exports","module","MAX_SAFE_INTEGER","reIsUint","isIndex","value","length","type","require_arrayLikeKeys","__commonJSMin","exports","module","baseTimes","isArguments","isArray","isBuffer","isIndex","isTypedArray","objectProto","hasOwnProperty","arrayLikeKeys","value","inherited","isArr","isArg","isBuff","isType","skipIndexes","result","length","key","require_nativeKeysIn","__commonJSMin","exports","module","nativeKeysIn","object","result","key","require_baseKeysIn","__commonJSMin","exports","module","isObject","isPrototype","nativeKeysIn","objectProto","hasOwnProperty","baseKeysIn","object","isProto","result","key","require_keysIn","__commonJSMin","exports","module","arrayLikeKeys","baseKeysIn","isArrayLike","keysIn","object","require_toPlainObject","__commonJSMin","exports","module","copyObject","keysIn","toPlainObject","value","require_baseMergeDeep","__commonJSMin","exports","module","assignMergeValue","cloneBuffer","cloneTypedArray","copyArray","initCloneObject","isArguments","isArray","isArrayLikeObject","isBuffer","isFunction","isObject","isPlainObject","isTypedArray","safeGet","toPlainObject","baseMergeDeep","object","source","key","srcIndex","mergeFunc","customizer","stack","objValue","srcValue","stacked","newValue","isCommon","isArr","isBuff","isTyped","require_baseMerge","__commonJSMin","exports","module","Stack","assignMergeValue","baseFor","baseMergeDeep","isObject","keysIn","safeGet","baseMerge","object","source","srcIndex","customizer","stack","srcValue","key","newValue","require_isIterateeCall","__commonJSMin","exports","module","eq","isArrayLike","isIndex","isObject","isIterateeCall","value","index","object","type","require_createAssigner","__commonJSMin","exports","module","baseRest","isIterateeCall","createAssigner","assigner","object","sources","index","length","customizer","guard","source","require_merge","__commonJSMin","exports","module","baseMerge","createAssigner","merge","object","source","srcIndex","require_mergeWith","__commonJSMin","exports","module","baseMerge","createAssigner","mergeWith","object","source","srcIndex","customizer","require_baseSet","__commonJSMin","exports","module","assignValue","castPath","isIndex","isObject","toKey","baseSet","object","path","value","customizer","index","length","lastIndex","nested","key","newValue","objValue","require_set","__commonJSMin","exports","module","baseSet","set","object","path","value","import_randexp","convertKBToMB","kb","mb","KEYS_TO_SKIP","isObject","value","deepMergeSchemas","schema1","schema2","key","schema2Value","schema1Value","originalArray","item","originalItem","DATE_FORMAT","compareDates","d1","d2","date1","date2","validateMinDate","value","minDate","result","validateMaxDate","maxDate","validateDate","schema","options","path","isString","isEmptyString","isUndefined","isEmpty","errors","isCheckbox","schema","CHECKBOX_ACK_ERROR_MESSAGE","getErrorMessage","value","validation","customErrorMessage","presentation","getTypeErrorMessage","valueToString","currentDate","DATE_FORMAT","limitKB","limitMB","convertKBToMB","formats","itemOrItems","schemaType","type","import_deepmerge","sort","fields","order","indexMap","key","index","a","b","indexA","indexB","setCustomOrder","schema","addCheckboxAttributes","inputType","field","schema","addOptions","options","getFieldOptions","addFields","originalSchema","strictInputType","asyncLoaders","formValues","fields","getFields","getInputTypeFromSchema","type","oneOf","format","items","getInputType","name","presentation","convertToOptions","nodeOptions","option","schemaOption","title","value","result","_","__","___","rest","enumAsOneOf","getObjectFields","key","isRequired","buildFieldSchema","setCustomOrder","getArrayFields","objectSchema","isFieldRequired","excludedSchemaProps","required","inputHasInnerFields","originalSchemaPresentation","schemaPresentation","deepmerge","_destinationArray","sourceArray","_options","originalLayoutConfig","layoutConfig","errorMessage","acc","asyncOptionsConfig","loader","isObjectValue","v","deepEqual","a","b","item","index","aKeys","bKeys","key","safeDeepClone","obj","err","validateArray","value","schema","options","jsonLogicContext","path","validateLength","validateUniqueItems","validateContains","validatePrefixItems","validateItems","errors","itemsLength","values","startIndex","i","item","validateSchema","contains","seen","prevItem","deepEqual","validateAllOf","value","schema","options","jsonLogicContext","path","i","subSchema","errors","validateSchema","validateAnyOf","errorGroups","schemaErrors","validateOneOf","validCount","validateNot","validateConst","value","schema","path","constValue","deepEqual","validateEnum","value","schema","path","enumValue","deepEqual","validateFile","value","schema","path","presentation","isExplicitFileInput","hasFileKeywords","file","isObjectValue","files","maxSizeInBytes","acceptedFormats","f","nameLower","extension","jsonLogic","getJsonLogicContextFromSchema","schema","value","validations","computedValues","containsHandlebars","replaceUndefinedAndNullValuesWithNaN","values","prev","key","validateJsonLogicRules","jsonLogicContext","path","validationName","validationData","formValue","errorMessage","_","handlebarsVar","computationName","jsonLogicComputation","computePropertyValues","name","rule","applyComputedAttrsToSchema","computedValuesDefinition","definition","computedValue","cycleThroughPropertiesAndApplyValues","schemaCopy","processProperty","propertySchema","computedAttrs","cycleThroughAttrsAndApplyValues","propertyName","evalStringOrTemplate","message","computation","applyNestedComputedValues","attrName","attributeName","compName","addCustomJsonLogicOperations","ops","func","removeCustomJsonLogicOperations","validateNumber","value","schema","path","errors","schemaType","getSchemaType","validateObject","value","schema","options","jsonLogicContext","path","isObjectValue","errors","key","propertySchema","validateSchema","ContentEncoding","ContentEncoding1","Format","Format1","TypeName","TypeName1","PATTERNS","formatValidationFunctions","Format","value","label","parts","part","num","hasDoubleColon","url","validateFormat","schema","path","errors","validateFn","validateString","value","schema","path","errors","schemaType","getSchemaType","valueLength","formatErrors","validateFormat","getSchemaType","schema","validateType","value","path","schemaType","valueType","type","validateJsonLogicSchema","options","jsonLogicContext","validateSchema","compilePatternProperties","patternProperties","pattern","rootJsonLogicContext","jsonLogicRootSchema","getJsonLogicContextFromSchema","validations","computedValues","rest","valueIsUndefined","errors","isExplicitFileInput","typeValidationErrors","isObjectValue","missingKeys","key","fieldValue","definedProps","compiledPatterns","isDefined","matchesPattern","regex","validateConst","validateEnum","validateObject","validateArray","validateString","validateNumber","validateFile","validateNot","validateAllOf","validateAnyOf","validateOneOf","validateCondition","validateDate","validateJsonLogicRules","evaluateIfCondition","value","ifNode","options","jsonLogicContext","path","validateSchema","validateCondition","schema","conditionIsTrue","calculateFinalSchema","schema","values","options","jsonLogicContext","getJsonLogicContextFromSchema","schemaCopy","safeDeepClone","applySchemaRules","applyComputedAttrsToSchema","evaluateConditional","rule","conditionIsTrue","evaluateIfCondition","hasTypeErrors","fieldName","fieldSchema","fieldValue","validateSchema","error","isObjectValue","conditionalRules","result","matches","processBranch","key","property","propertySchema","branch","branchSchema","deepMergeSchemas","updateFieldProperties","fields","originalSchema","newFields","buildFieldSchema","field","newField","f","removeNonExistentProperties","originalFieldSchema","obj","newObj","transformErrorPath","path","result","i","segment","validationErrorsToFormErrors","errors","error","segments","current","lastSegment","addErrorMessages","schema","value","validation","customErrorMessage","getErrorMessage","applyCustomErrorMessages","fieldSchema","validate","options","validateSchema","errorsWithMessages","processedErrors","formErrors","buildFields","params","originalSchema","strictInputType","asyncLoaders","formValues","rootField","buildFieldSchema","fields","layout","field","validateOptions","name","func","createHeadlessForm","initialValues","updatedSchema","calculateFinalSchema","customJsonLogicOps","addCustomJsonLogicOperations","updateFieldProperties","removeCustomJsonLogicOperations","import_difference","import_get","import_intersection","import_merge","import_mergeWith","import_set","shortToFullPath","path","standardizeAttrs","attrs","errorMessage","presentation","properties","rest","mergeReplaceArray","_","newVal","isConditionalReferencingAnyPickedField","condition","fieldsToPick","ifCondition","thenCondition","elseCondition","intersection","rewriteFields","schema","fieldsConfig","warnings","shortPath","mutation","fieldPath","fieldAttrs","get","fieldChanges","mergeWith","result","rewriteAllFields","configCallback","context","parentName","fieldName","fullName","callbackResult","resultWithStandardizedAttrs","reorderFields","configOrder","originalOrder","orderConfig","remaining","difference","createFields","recursiveFieldAttrs","fieldInObjectPath","set","merge","pickFields","originalSchema","newSchema","attrKey","attrValue","newConditionalArray","missingFields","index","findMissingFields","name","conditional","fields","modifySchema","config","resultRewrite","resultRewriteAll","resultCreate","resultPick","finalSchema","resultReorder","DEFAULT_LAYOUT_CONFIG","isValidLayoutConfig","layout","responsiveKeys","key","value","colProps","prop","responsiveValue","normalizeLayoutConfig","getFieldLayoutInfo","field","getRootLayoutInfo","getFormContainerLayout","fields","generateCSSGridProperties","normalized","properties","values","v","maxValue","colStart","colEnd","generateResponsiveCSS","breakpoints","mediaQueries","breakpoint","columns","minWidth","generateResponsiveFieldCSS","span","start","end","getBaseFieldValue"]}